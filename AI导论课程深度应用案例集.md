# äººå·¥æ™ºèƒ½å¯¼è®ºè¯¾ç¨‹æ·±åº¦åº”ç”¨æ¡ˆä¾‹é›†

**åŸºäº shiro123444 é¡¹ç›®å®è·µçš„å®Œæ•´æ•™å­¦æ¡ˆä¾‹åº“**

---

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

**æŠ¥å‘Šäºº**: shiro123444  
**ç¼–åˆ¶æ—¥æœŸ**: 2025å¹´12æœˆ18æ—¥  
**GitHubä¸»é¡µ**: https://github.com/shiro123444  
**åˆ†æèŒƒå›´**: å…¨éƒ¨9ä¸ªä»“åº“çš„æ·±åº¦æŠ€æœ¯åˆ†æ  
**åº”ç”¨åœºæ™¯**: äººå·¥æ™ºèƒ½å¯¼è®ºè¯¾ç¨‹å®è·µæ•™å­¦  

---

## ï¿½ï¿½ è¯¾ç¨‹å¯¹åº”å…³ç³»æ€»è§ˆ

| è¯¾ç¨‹ç« èŠ‚ | å¯¹åº”é¡¹ç›® | åº”ç”¨æ¡ˆä¾‹ç¼–å· | éš¾åº¦ç­‰çº§ |
|---------|---------|-------------|---------|
| **1. AIåŸºç¡€ä¸æ™ºèƒ½ä½“** | social-media-ai-system | æ¡ˆä¾‹1 | â˜…â˜…â˜…â˜…â˜… |
| **2. æœºå™¨å­¦ä¹ ç®—æ³•** | brain | æ¡ˆä¾‹2 | â˜…â˜…â˜…â˜…â˜… |
| **3. è‡ªç„¶è¯­è¨€å¤„ç†** | social-media-ai-system | æ¡ˆä¾‹3 | â˜…â˜…â˜…â˜…â˜† |
| **4. çŸ¥è¯†è¡¨ç¤ºä¸æ¨ç†** | kg | æ¡ˆä¾‹4 | â˜…â˜…â˜…â˜…â˜† |
| **5. å¤šæ¨¡æ€AI** | -- (å®æ—¶æ„Ÿå®˜) | æ¡ˆä¾‹5 | â˜…â˜…â˜…â˜…â˜… |
| **6. æ•°æ®ç§‘å­¦åŸºç¡€** | brain | æ¡ˆä¾‹6 | â˜…â˜…â˜…â˜†â˜† |
| **7. æ•™è‚²AIåº”ç”¨** | CS50 | æ¡ˆä¾‹7 | â˜…â˜…â˜…â˜†â˜† |
| **8. æ¡Œé¢åº”ç”¨å¼€å‘** | student-management-system | æ¡ˆä¾‹8 | â˜…â˜…â˜…â˜†â˜† |
| **9. åŒ»ç–—AI** | medcial-Q-A-SYSTEM | æ¡ˆä¾‹9 | â˜…â˜…â˜…â˜†â˜† |

---

## ğŸ“š å®Œæ•´æ¡ˆä¾‹åº“ç´¢å¼•


### æ¡ˆä¾‹ç´¢å¼•

1. **[æ¡ˆä¾‹1] HotFlow AI - ä¼ä¸šçº§æ™ºèƒ½ä½“å·¥ä½œæµç³»ç»Ÿ** (â­â­â­â­â­)
   - è¯¾ç¨‹æ¨¡å—: AIåŸºç¡€ã€æ™ºèƒ½ä½“ç³»ç»Ÿã€NLP
   - æŠ€æœ¯å…³é”®è¯: Agent Framework, MCPåè®®, DeepSeek LLM
   - æ•™å­¦æ—¶é•¿: 4-6è¯¾æ—¶
   
2. **[æ¡ˆä¾‹2] SSVEPè„‘æœºæ¥å£ - æœºå™¨å­¦ä¹ ç®—æ³•ä¼˜åŒ–å®æˆ˜** (â­â­â­â­â­)
   - è¯¾ç¨‹æ¨¡å—: æœºå™¨å­¦ä¹ ã€ä¿¡å·å¤„ç†ã€ä¸»åŠ¨å­¦ä¹ 
   - æŠ€æœ¯å…³é”®è¯: CCA, TRCA, Filter-Bank, Active Learning
   - æ•™å­¦æ—¶é•¿: 4-6è¯¾æ—¶

3. **[æ¡ˆä¾‹3] æ™ºèƒ½å†…å®¹ç”Ÿæˆ - NLPåº”ç”¨å…¨æµç¨‹** (â­â­â­â­â˜†)
   - è¯¾ç¨‹æ¨¡å—: è‡ªç„¶è¯­è¨€å¤„ç†ã€æ–‡æœ¬ç”Ÿæˆ
   - æŠ€æœ¯å…³é”®è¯: LLM, Prompt Engineering, RAG
   - æ•™å­¦æ—¶é•¿: 3-4è¯¾æ—¶

4. **[æ¡ˆä¾‹4] Thinking Quantum - çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ** (â­â­â­â­â˜†)
   - è¯¾ç¨‹æ¨¡å—: çŸ¥è¯†è¡¨ç¤ºã€å›¾æ•°æ®åº“ã€GraphRAG
   - æŠ€æœ¯å…³é”®è¯: Neo4j, çŸ¥è¯†å›¾è°±, D3.jså¯è§†åŒ–
   - æ•™å­¦æ—¶é•¿: 3-4è¯¾æ—¶

5. **[æ¡ˆä¾‹5] å¿ƒç†å’¨è¯¢åŠ©æ‰‹ - å¤šæ¨¡æ€AIç³»ç»Ÿ** (â­â­â­â­â˜…)
   - è¯¾ç¨‹æ¨¡å—: å¤šæ¨¡æ€å­¦ä¹ ã€æƒ…ç»ªè¯†åˆ«ã€è¯­éŸ³å¤„ç†
   - æŠ€æœ¯å…³é”®è¯: Face++, Web Speech API, TTS, GPGPU
   - æ•™å­¦æ—¶é•¿: 4-5è¯¾æ—¶

6. **[æ¡ˆä¾‹6] æ•°æ®åˆ†æä¸å¯è§†åŒ–å®è·µ** (â­â­â­â˜†â˜†)
   - è¯¾ç¨‹æ¨¡å—: æ•°æ®ç§‘å­¦åŸºç¡€
   - æŠ€æœ¯å…³é”®è¯: NumPy, Pandas, Matplotlib, ç»Ÿè®¡åˆ†æ
   - æ•™å­¦æ—¶é•¿: 2-3è¯¾æ—¶

7. **[æ¡ˆä¾‹7] CS50å­¦ä¹ å¹³å° - æ•™è‚²æŠ€æœ¯åº”ç”¨** (â­â­â­â˜†â˜†)
   - è¯¾ç¨‹æ¨¡å—: æ•™è‚²AIã€çŸ¥è¯†ç®¡ç†
   - æŠ€æœ¯å…³é”®è¯: VitePress, CI/CD, è‡ªåŠ¨åŒ–å·¥ä½œæµ
   - æ•™å­¦æ—¶é•¿: 2-3è¯¾æ—¶

8. **[æ¡ˆä¾‹8] å­¦ç”Ÿç®¡ç†ç³»ç»Ÿ - æ™ºèƒ½æ¡Œé¢åº”ç”¨** (â­â­â­â˜†â˜†)
   - è¯¾ç¨‹æ¨¡å—: è½¯ä»¶å·¥ç¨‹ã€æ•°æ®åº“åº”ç”¨
   - æŠ€æœ¯å…³é”®è¯: PyQt5, QML, SQLite, MVC
   - æ•™å­¦æ—¶é•¿: 2-3è¯¾æ—¶

9. **[æ¡ˆä¾‹9] åŒ»ç–—é—®ç­”ç³»ç»Ÿ - å‚ç›´é¢†åŸŸAI** (â­â­â­â˜†â˜†)
   - è¯¾ç¨‹æ¨¡å—: é¢†åŸŸAIåº”ç”¨
   - æŠ€æœ¯å…³é”®è¯: é¢†åŸŸçŸ¥è¯†ã€é—®ç­”ç³»ç»Ÿ
   - æ•™å­¦æ—¶é•¿: 2-3è¯¾æ—¶

---

# ç¬¬ä¸€éƒ¨åˆ†ï¼šæ ¸å¿ƒAIæŠ€æœ¯æ¡ˆä¾‹

---

## ğŸ“– æ¡ˆä¾‹1: HotFlow AI - ä¼ä¸šçº§æ™ºèƒ½ä½“å·¥ä½œæµç³»ç»Ÿ

### 1.1 æ¡ˆä¾‹æ¦‚è¿°

**é¡¹ç›®åç§°**: HotFlow AI - æ™ºèƒ½ç¤¾äº¤åª’ä½“å†…å®¹ç”Ÿäº§ç³»ç»Ÿ  
**ä»“åº“**: social-media-ai-system  
**æŠ€æœ¯çº§åˆ«**: ä¼ä¸šçº§AIåº”ç”¨  
**è¯¾ç¨‹é€‚ç”¨**: AIåŸºç¡€ã€æ™ºèƒ½ä½“ç³»ç»Ÿã€è‡ªç„¶è¯­è¨€å¤„ç†  

#### ç³»ç»Ÿç®€ä»‹

HotFlow AIæ˜¯ä¸€ä¸ªåŸºäºMicrosoft Agent Frameworkæ„å»ºçš„ä¼ä¸šçº§æ™ºèƒ½ä½“ç³»ç»Ÿï¼Œå®ç°äº†ç¤¾äº¤åª’ä½“å†…å®¹ç”Ÿäº§çš„å…¨ç”Ÿå‘½å‘¨æœŸè‡ªåŠ¨åŒ–ã€‚ç³»ç»Ÿé€šè¿‡å¤šä¸ªä¸“ä¸šæ™ºèƒ½ä½“çš„ååŒå·¥ä½œï¼Œæ¨¡æ‹Ÿäººç±»çš„"æ„ŸçŸ¥-è®¤çŸ¥-åˆ›ä½œ-è¡ŒåŠ¨"è®¤çŸ¥è¿‡ç¨‹ã€‚

### 1.2 æ•™å­¦ç›®æ ‡

#### çŸ¥è¯†ç›®æ ‡
- ç†è§£æ™ºèƒ½ä½“ï¼ˆAgentï¼‰çš„æ¦‚å¿µå’Œå·¥ä½œåŸç†
- æŒæ¡Model Context Protocol (MCP)æ ‡å‡†
- å­¦ä¹ é¡ºåºå·¥ä½œæµï¼ˆSequential Workflowï¼‰è®¾è®¡
- äº†è§£å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰çš„å®é™…åº”ç”¨

#### èƒ½åŠ›ç›®æ ‡
- èƒ½å¤Ÿè®¾è®¡å’Œå®ç°å¤šæ™ºèƒ½ä½“åä½œç³»ç»Ÿ
- èƒ½å¤Ÿé›†æˆå¤–éƒ¨å·¥å…·å’ŒAPI
- èƒ½å¤Ÿå¤„ç†AIç³»ç»Ÿçš„é”™è¯¯å’Œè¾¹ç•Œæƒ…å†µ
- èƒ½å¤Ÿè¯„ä¼°å’Œä¼˜åŒ–AIç³»ç»Ÿæ€§èƒ½

#### ç´ è´¨ç›®æ ‡
- åŸ¹å…»ç³»ç»Ÿæ€§æ€ç»´èƒ½åŠ›
- æå‡é—®é¢˜åˆ†è§£å’ŒæŠ½è±¡èƒ½åŠ›
- å¢å¼ºåˆ›æ–°æ„è¯†å’Œå·¥ç¨‹å®è·µèƒ½åŠ›

### 1.3 æ ¸å¿ƒæŠ€æœ¯æ·±åº¦è§£æ

#### 1.3.1 æ™ºèƒ½ä½“æ¶æ„ï¼ˆAgent Architectureï¼‰

**ç†è®ºåŸºç¡€ï¼š**

æ™ºèƒ½ä½“æ˜¯AIé¢†åŸŸçš„æ ¸å¿ƒæ¦‚å¿µï¼Œè¡¨ç¤ºèƒ½å¤Ÿæ„ŸçŸ¥ç¯å¢ƒã€åšå‡ºå†³ç­–å¹¶é‡‡å–è¡ŒåŠ¨çš„è‡ªæ²»å®ä½“ã€‚HotFlow AIå®ç°äº†å››ä¸ªä¸“ä¸šæ™ºèƒ½ä½“ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Agent Framework ç¼–æ’å±‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. çƒ­ç‚¹è·å–æ™ºèƒ½ä½“ (Hotspot Executor)           â”‚
â”‚     â””â”€ å·¥å…·: daily-hot-mcp                      â”‚
â”‚     â””â”€ èŒè´£: ç›‘æ§15+å¹³å°çƒ­æ¦œ                    â”‚
â”‚                                                  â”‚
â”‚  2. æ·±åº¦åˆ†ææ™ºèƒ½ä½“ (Analysis Executor)          â”‚
â”‚     â””â”€ å·¥å…·: think-tool                         â”‚
â”‚     â””â”€ èŒè´£: è¶‹åŠ¿è¯†åˆ«ä¸ç­–ç•¥åˆ¶å®š                 â”‚
â”‚                                                  â”‚
â”‚  3. å†…å®¹åˆ›ä½œæ™ºèƒ½ä½“ (Creation Executor)          â”‚
â”‚     â””â”€ å·¥å…·: DeepSeek LLM                       â”‚
â”‚     â””â”€ èŒè´£: å¤šæ¨¡æ€å†…å®¹ç”Ÿæˆ                     â”‚
â”‚                                                  â”‚
â”‚  4. è‡ªåŠ¨å‘å¸ƒæ™ºèƒ½ä½“ (Publish Executor)           â”‚
â”‚     â””â”€ å·¥å…·: xiaohongshu-mcp                    â”‚
â”‚     â””â”€ èŒè´£: å†…å®¹å‘å¸ƒå’Œç›‘æ§                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å®ç°ç»†èŠ‚ï¼š**

```python
from autogen import SequentialBuilder, WorkflowContext

class MCPHotspotExecutor:
    """çƒ­ç‚¹è·å–æ‰§è¡Œå™¨"""
    
    @handler
    async def execute(self, context: WorkflowContext):
        # 1. åŠ¨æ€åˆ›å»ºMCPå·¥å…·è¿æ¥
        async with MCPStreamableHTTPTool(url=MCP_URL) as tool:
            # 2. åˆ›å»ºç»‘å®šå·¥å…·çš„ä¸´æ—¶Agent
            agent = client.create_agent(
                model="deepseek-chat",
                tools=[tool],
                system_message="ä½ æ˜¯çƒ­ç‚¹åˆ†æä¸“å®¶..."
            )
            
            # 3. æ‰§è¡ŒæŸ¥è¯¢
            result = await agent.run(
                "è·å–ç§‘æŠ€é¢†åŸŸçš„æœ€æ–°çƒ­ç‚¹"
            )
            
            # 4. å°†ç»“æœä¼ é€’ç»™ä¸‹ä¸€ä¸ªæ™ºèƒ½ä½“
            context.set_data("hotspots", result)
        
        return context
```

**æ•™å­¦è¦ç‚¹ï¼š**

1. **æ™ºèƒ½ä½“è®¾è®¡æ¨¡å¼**
   - å•ä¸€èŒè´£åŸåˆ™ï¼šæ¯ä¸ªæ™ºèƒ½ä½“ä¸“æ³¨ä¸€ä¸ªä»»åŠ¡
   - æ¥å£éš”ç¦»ï¼šé€šè¿‡WorkflowContextä¼ é€’æ•°æ®
   - ä¾èµ–å€’ç½®ï¼šåŸºäºæŠ½è±¡çš„å·¥å…·æ¥å£

2. **å¼‚æ­¥ç¼–ç¨‹å®è·µ**
   - async/awaitè¯­æ³•çš„æ­£ç¡®ä½¿ç”¨
   - èµ„æºçš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆasync withï¼‰
   - å¹¶å‘ä¸å¹¶è¡Œçš„åŒºåˆ«

#### 1.3.2 Model Context Protocol (MCP)

**ç†è®ºåŸºç¡€ï¼š**

MCPæ˜¯ä¸€ä¸ªæ ‡å‡†åŒ–åè®®ï¼Œç”¨äºåœ¨AIåº”ç”¨å’Œå¤–éƒ¨å·¥å…·ä¹‹é—´å»ºç«‹è¿æ¥ã€‚å®ƒç±»ä¼¼äºHTTPä¹‹äºWebï¼Œä¸ºå·¥å…·é›†æˆæä¾›äº†ç»Ÿä¸€æ¥å£ã€‚

**åè®®æ¶æ„ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         MCP          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AIåº”ç”¨     â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  å·¥å…·æœåŠ¡å™¨  â”‚
â”‚ (Client)    â”‚                      â”‚  (Server)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                     â”‚
       â”‚  1. discover_tools()                â”‚
       â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚
       â”‚  2. tool_list                       â”‚
       â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
       â”‚  3. call_tool(params)               â”‚
       â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚
       â”‚  4. result                          â”‚
       â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
```

**å®ç°ç¤ºä¾‹ï¼š**

```python
# MCP Serverç«¯ï¼ˆå·¥å…·æä¾›æ–¹ï¼‰
class DailyHotMCPServer:
    def list_tools(self):
        """åˆ—å‡ºå¯ç”¨å·¥å…·"""
        return [
            {
                "name": "get_hot_topics",
                "description": "è·å–æŒ‡å®šå¹³å°çš„çƒ­é—¨è¯é¢˜",
                "parameters": {
                    "platform": "bilibili|weibo|zhihu",
                    "category": "tech|entertainment|..."
                }
            }
        ]
    
    def call_tool(self, tool_name, params):
        """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
        if tool_name == "get_hot_topics":
            return self._fetch_hot_topics(
                params["platform"],
                params["category"]
            )

# MCP Clientç«¯ï¼ˆAIåº”ç”¨ï¼‰
class MCPStreamableHTTPTool:
    async def __aenter__(self):
        # å»ºç«‹è¿æ¥
        self.session = await aiohttp.ClientSession()
        self.tools = await self._discover_tools()
        return self
    
    async def _discover_tools(self):
        """å·¥å…·å‘ç°"""
        response = await self.session.get(
            f"{self.url}/tools"
        )
        return await response.json()
```

**æ•™å­¦è¦ç‚¹ï¼š**

1. **åè®®è®¾è®¡åŸåˆ™**
   - ç®€å•æ€§ï¼šæ˜“äºç†è§£å’Œå®ç°
   - å¯æ‰©å±•æ€§ï¼šæ”¯æŒæ–°å·¥å…·çš„æ·»åŠ 
   - æ ‡å‡†åŒ–ï¼šè·¨å¹³å°å…¼å®¹

2. **RESTful APIè®¾è®¡**
   - èµ„æºå®šä½ï¼ˆURIï¼‰
   - HTTPæ–¹æ³•è¯­ä¹‰
   - çŠ¶æ€ç ä½¿ç”¨

#### 1.3.3 è®¤çŸ¥å¢å¼ºæœºåˆ¶ï¼ˆCognitive Enhancementï¼‰

**ç†è®ºåŸºç¡€ï¼š**

åŸºäºåŒè¿‡ç¨‹ç†è®ºï¼ˆDual Process Theoryï¼‰ï¼Œäººç±»æ€ç»´åˆ†ä¸ºå¿«é€Ÿç›´è§‰çš„"ç³»ç»Ÿ1"å’Œç¼“æ…¢ç†æ€§çš„"ç³»ç»Ÿ2"ã€‚HotFlow AIé€šè¿‡think-toolå®ç°"ç³»ç»Ÿ2"æ€ç»´ã€‚

**å®ç°æ¶æ„ï¼š**

```xml
<thinking>
  <!-- é—®é¢˜åˆ†æ -->
  <problem_analysis>
    å½“å‰ä»»åŠ¡ï¼šåˆ†æçƒ­ç‚¹è¯é¢˜
    å…³é”®æŒ‘æˆ˜ï¼šåŒºåˆ†çŸ­æœŸçƒ­ç‚¹å’Œé•¿æœŸè¶‹åŠ¿
  </problem_analysis>
  
  <!-- ç­–ç•¥åˆ¶å®š -->
  <strategy>
    1. æŒ‰è¯é¢˜ç±»å‹åˆ†ç±»
    2. åˆ†æè·¨å¹³å°ä¸€è‡´æ€§
    3. è¯„ä¼°ä¼ æ’­é€Ÿåº¦
  </strategy>
  
  <!-- æ¨ç†è¿‡ç¨‹ -->
  <reasoning>
    è¯é¢˜Aåœ¨Bç«™å’ŒçŸ¥ä¹åŒæ—¶å‡ºç° â†’ è·¨å¹³å°çƒ­åº¦
    ä¼ æ’­é€Ÿåº¦å¿«ä½†æŒç»­æ—¶é—´çŸ­ â†’ çŸ­æœŸçƒ­ç‚¹
    ç»“è®ºï¼šé€‚åˆå¿«é€Ÿå“åº”ï¼Œä¸é€‚åˆæ·±åº¦å†…å®¹
  </reasoning>
</thinking>

<answer>
  æ¨èè¯é¢˜Bï¼šAIç¼–ç¨‹åŠ©æ‰‹
  ç†ç”±ï¼šé•¿æœŸè¶‹åŠ¿ï¼Œé€‚åˆæ·±åº¦å†…å®¹åˆ›ä½œ
</answer>
```

**Pythonå®ç°ï¼š**

```python
class ThinkToolExecutor:
    """è®¤çŸ¥å¢å¼ºæ‰§è¡Œå™¨"""
    
    async def execute(self, context: WorkflowContext):
        hotspots = context.get_data("hotspots")
        
        # å¼ºåˆ¶æ¨¡å‹è¾“å‡ºæ€è€ƒè¿‡ç¨‹
        prompt = f"""
        è¯·åˆ†æä»¥ä¸‹çƒ­ç‚¹æ•°æ®ï¼Œåœ¨<thinking>æ ‡ç­¾ä¸­å±•ç¤ºä½ çš„åˆ†æè¿‡ç¨‹ï¼š
        
        æ•°æ®ï¼š{hotspots}
        
        è¦æ±‚ï¼š
        1. åœ¨<thinking>ä¸­è¿›è¡Œå¤šæ­¥æ¨ç†
        2. åœ¨<answer>ä¸­ç»™å‡ºæœ€ç»ˆç»“è®º
        """
        
        response = await self.llm.generate(prompt)
        
        # æå–æ€è€ƒè¿‡ç¨‹å’Œç­”æ¡ˆ
        thinking = self._extract_tag(response, "thinking")
        answer = self._extract_tag(response, "answer")
        
        # è®°å½•è®¤çŸ¥è¿‡ç¨‹ï¼ˆç”¨äºæ”¹è¿›å’Œå®¡è®¡ï¼‰
        self.logger.info(f"Thinking: {thinking}")
        
        context.set_data("analysis", answer)
        return context
```

**æ•™å­¦è¦ç‚¹ï¼š**

1. **Prompt EngineeringæŠ€å·§**
   - ç»“æ„åŒ–è¾“å‡ºæ§åˆ¶
   - æ€ç»´é“¾ï¼ˆChain of Thoughtï¼‰
   - å°‘æ ·æœ¬å­¦ä¹ ï¼ˆFew-shot Learningï¼‰

2. **è®¤çŸ¥ç§‘å­¦åº”ç”¨**
   - åŒè¿‡ç¨‹ç†è®ºçš„è®¡ç®—å®ç°
   - å…ƒè®¤çŸ¥ç›‘æ§
   - æ¨ç†è·¯å¾„å¯è§†åŒ–

### 1.4 è¯¾ç¨‹æ•™å­¦è®¾è®¡

#### è¯¾æ—¶1-2: æ™ºèƒ½ä½“åŸºç¡€ï¼ˆ2è¯¾æ—¶ï¼‰

**æ•™å­¦å†…å®¹ï¼š**
1. æ™ºèƒ½ä½“æ¦‚å¿µä¸åˆ†ç±»
2. Agent Frameworkæ¶æ„
3. ç®€å•æ™ºèƒ½ä½“å®ç°

**å®è·µä»»åŠ¡ï¼š**
```python
# ä»»åŠ¡1ï¼šå®ç°å¤©æ°”æŸ¥è¯¢æ™ºèƒ½ä½“
class WeatherAgent:
    async def execute(self, city: str):
        # TODO: è°ƒç”¨å¤©æ°”API
        # TODO: è§£æç»“æœ
        # TODO: è¿”å›è‡ªç„¶è¯­è¨€æè¿°
        pass

# ä»»åŠ¡2ï¼šå®ç°å¤šè½®å¯¹è¯æ™ºèƒ½ä½“
class ChatAgent:
    def __init__(self):
        self.history = []
    
    async def chat(self, user_input: str):
        # TODO: ç»´æŠ¤å¯¹è¯å†å²
        # TODO: ç”Ÿæˆä¸Šä¸‹æ–‡ç›¸å…³å›å¤
        pass
```

**è¯„ä¼°æ ‡å‡†ï¼š**
- æ™ºèƒ½ä½“èƒ½æ­£ç¡®å“åº”ç”¨æˆ·è¯·æ±‚ï¼ˆ30%ï¼‰
- ä»£ç ç»“æ„æ¸…æ™°ï¼Œæ³¨é‡Šå®Œæ•´ï¼ˆ20%ï¼‰
- é”™è¯¯å¤„ç†å®Œå–„ï¼ˆ20%ï¼‰
- ç”¨æˆ·ä½“éªŒè‰¯å¥½ï¼ˆ30%ï¼‰

#### è¯¾æ—¶3-4: MCPåè®®ä¸å·¥å…·é›†æˆï¼ˆ2è¯¾æ—¶ï¼‰

**æ•™å­¦å†…å®¹ï¼š**
1. MCPåè®®è¯¦è§£
2. HTTP/WebSocketé€šä¿¡
3. å·¥å…·å‘ç°ä¸è°ƒç”¨

**å®è·µä»»åŠ¡ï¼š**
```python
# ä»»åŠ¡ï¼šå¼€å‘è®¡ç®—å™¨MCPæœåŠ¡å™¨
class CalculatorMCPServer:
    def list_tools(self):
        """
        è¿”å›å·¥å…·åˆ—è¡¨ï¼š
        - add: åŠ æ³•
        - subtract: å‡æ³•
        - multiply: ä¹˜æ³•
        - divide: é™¤æ³•
        """
        pass
    
    def call_tool(self, tool_name, params):
        """æ‰§è¡Œè®¡ç®—"""
        pass

# å®¢æˆ·ç«¯è°ƒç”¨ç¤ºä¾‹
async with MCPClient("http://localhost:8000") as client:
    tools = await client.discover_tools()
    result = await client.call_tool("add", {"a": 5, "b": 3})
    print(result)  # 8
```

#### è¯¾æ—¶5-6: å®Œæ•´ç³»ç»Ÿå®ç°ï¼ˆ2è¯¾æ—¶ï¼‰

**ç»¼åˆé¡¹ç›®ï¼š**
æ„å»ºä¸€ä¸ªç®€åŒ–ç‰ˆçš„HotFlow AIç³»ç»Ÿ

**è¦æ±‚ï¼š**
1. å®ç°è‡³å°‘3ä¸ªæ™ºèƒ½ä½“
2. ä½¿ç”¨MCPè¿æ¥å¤–éƒ¨å·¥å…·
3. å®ç°é¡ºåºå·¥ä½œæµ
4. æä¾›å®Œæ•´æ–‡æ¡£

**è¯„åˆ†ç»†åˆ™ï¼š**
| é¡¹ç›® | åˆ†å€¼ | è¯„åˆ†æ ‡å‡† |
|------|------|---------|
| æ¶æ„è®¾è®¡ | 25 | æ¨¡å—åˆ’åˆ†åˆç†ï¼Œæ¥å£æ¸…æ™° |
| ä»£ç å®ç° | 30 | åŠŸèƒ½å®Œæ•´ï¼Œä»£ç è§„èŒƒ |
| å·¥å…·é›†æˆ | 20 | MCPåè®®æ­£ç¡®ä½¿ç”¨ |
| æ–‡æ¡£è´¨é‡ | 15 | README + APIæ–‡æ¡£ |
| åˆ›æ–°æ€§ | 10 | ç‹¬ç‰¹åŠŸèƒ½æˆ–ä¼˜åŒ– |

### 1.5 æ•™å­¦èµ„æº

#### ä»£ç ç¤ºä¾‹åº“

```
teaching-resources/
â”œâ”€â”€ 01-basic-agent/
â”‚   â”œâ”€â”€ weather_agent.py        # å¤©æ°”æŸ¥è¯¢ç¤ºä¾‹
â”‚   â”œâ”€â”€ chat_agent.py            # å¯¹è¯æ™ºèƒ½ä½“
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ 02-mcp-protocol/
â”‚   â”œâ”€â”€ calculator_server.py     # MCPæœåŠ¡å™¨
â”‚   â”œâ”€â”€ calculator_client.py     # MCPå®¢æˆ·ç«¯
â”‚   â””â”€â”€ test_mcp.py
â”œâ”€â”€ 03-full-system/
â”‚   â”œâ”€â”€ hotflow_mini/           # ç®€åŒ–ç‰ˆHotFlow
â”‚   â”œâ”€â”€ tests/
â”‚   â””â”€â”€ docs/
â””â”€â”€ slides/                     # PPTè¯¾ä»¶
    â”œâ”€â”€ lesson1.pptx
    â”œâ”€â”€ lesson2.pptx
    â””â”€â”€ lesson3.pptx
```

#### æ¨èé˜…è¯»

1. **è®ºæ–‡**
   - *Attention Is All You Need* (Transformeræ¶æ„)
   - *ReAct: Synergizing Reasoning and Acting in Language Models*

2. **æ–‡æ¡£**
   - Microsoft AutoGen Documentation
   - Model Context Protocol Specification

3. **è§†é¢‘**
   - Andrew Ngçš„AI Agentè¯¾ç¨‹
   - DeepLearning.AIçš„LangChainæ•™ç¨‹

### 1.6 å¸¸è§é—®é¢˜ä¸è§£ç­”

**Q1: ä¸ºä»€ä¹ˆéœ€è¦å¤šä¸ªæ™ºèƒ½ä½“ï¼Œä¸€ä¸ªä¸å¤Ÿå—ï¼Ÿ**

A: å•ä¸€æ™ºèƒ½ä½“å®¹æ˜“å¯¼è‡´ï¼š
- èŒè´£ä¸æ¸…ï¼šä¸€ä¸ªAgentåšæ‰€æœ‰äº‹æƒ…
- éš¾ä»¥ç»´æŠ¤ï¼šä»£ç è€¦åˆåº¦é«˜
- æ€§èƒ½ç“¶é¢ˆï¼šæ— æ³•å¹¶è¡Œå¤„ç†

å¤šæ™ºèƒ½ä½“éµå¾ª"åˆ†è€Œæ²»ä¹‹"æ€æƒ³ï¼Œæ¯ä¸ªAgentä¸“æ³¨ä¸€ä¸ªä»»åŠ¡ï¼Œç±»ä¼¼å¾®æœåŠ¡æ¶æ„ã€‚

**Q2: MCPå’Œæ™®é€šAPIæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ**

A: ä¸»è¦åŒºåˆ«ï¼š
| æ–¹é¢ | æ™®é€šAPI | MCP |
|------|---------|-----|
| ç›®çš„ | æ•°æ®äº¤æ¢ | å·¥å…·é›†æˆ |
| æ¥å£ | å›ºå®šç«¯ç‚¹ | åŠ¨æ€å‘ç° |
| è¯­ä¹‰ | HTTPæ–¹æ³• | å·¥å…·æè¿° |
| AIå‹å¥½åº¦ | ä½ | é«˜ |

MCPä¸“ä¸ºAIåº”ç”¨è®¾è®¡ï¼Œæä¾›äº†å·¥å…·æè¿°ã€å‚æ•°éªŒè¯ç­‰AIå‹å¥½ç‰¹æ€§ã€‚

**Q3: å¦‚ä½•é¿å…AIäº§ç”Ÿå¹»è§‰ï¼ˆHallucinationï¼‰ï¼Ÿ**

A: ç­–ç•¥ï¼š
1. **çº¦æŸè¾“å‡ºæ ¼å¼**ï¼šä½¿ç”¨XML/JSONå¼ºåˆ¶ç»“æ„åŒ–
2. **å¼•å…¥å¤–éƒ¨çŸ¥è¯†**ï¼šRAGï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰
3. **å¤šæ­¥éªŒè¯**ï¼šThink-toolå¼ºåˆ¶æ¨ç†è¿‡ç¨‹
4. **æ¸©åº¦å‚æ•°è°ƒæ•´**ï¼šé™ä½temperatureå‡å°‘éšæœºæ€§

### 1.7 æ‰©å±•é˜…è¯»

#### è¿›é˜¶ä¸»é¢˜

1. **LangGraph vs AutoGen**
   - å·¥ä½œæµç¼–æ’çš„ä¸åŒèŒƒå¼
   - ä¼˜ç¼ºç‚¹å¯¹æ¯”

2. **Agentå®‰å…¨æ€§**
   - Prompt Injectionæ”»å‡»
   - æ²™ç®±éš”ç¦»æŠ€æœ¯

3. **å¤§è§„æ¨¡Agentç³»ç»Ÿ**
   - åˆ†å¸ƒå¼Agentåè°ƒ
   - è´Ÿè½½å‡è¡¡ç­–ç•¥

---

## ğŸ“– æ¡ˆä¾‹2: SSVEPè„‘æœºæ¥å£ - æœºå™¨å­¦ä¹ ç®—æ³•ä¼˜åŒ–å®æˆ˜

### 2.1 æ¡ˆä¾‹æ¦‚è¿°

**é¡¹ç›®åç§°**: SSVEPå¤šç®—æ³•å¯¹æ¯”å®éªŒç³»ç»Ÿ  
**ä»“åº“**: brain  
**æŠ€æœ¯çº§åˆ«**: ç ”ç©¶çº§æœºå™¨å­¦ä¹ åº”ç”¨  
**è¯¾ç¨‹é€‚ç”¨**: æœºå™¨å­¦ä¹ ã€ä¿¡å·å¤„ç†ã€æ•°æ®ç§‘å­¦  

#### ç³»ç»Ÿç®€ä»‹

è¿™æ˜¯ä¸€ä¸ªåŸºäºç¨³æ€è§†è§‰è¯±å‘ç”µä½ï¼ˆSSVEPï¼‰çš„è„‘æœºæ¥å£ç³»ç»Ÿï¼Œé€šè¿‡ä¸‰ç§ä¸åŒç®—æ³•çš„ç³»ç»Ÿå¯¹æ¯”ï¼Œå±•ç¤ºäº†æœºå™¨å­¦ä¹ ç®—æ³•çš„ä¼˜åŒ–è¿‡ç¨‹ã€‚é¡¹ç›®å®ç°äº†ä»89.58%åˆ°100%å‡†ç¡®ç‡çš„æå‡ï¼Œæ˜¯æœºå™¨å­¦ä¹ è¯¾ç¨‹çš„ç»ä½³å®æˆ˜æ¡ˆä¾‹ã€‚

### 2.2 æ•™å­¦ç›®æ ‡

#### çŸ¥è¯†ç›®æ ‡
- ç†è§£ç»å…¸æœºå™¨å­¦ä¹ ç®—æ³•ï¼ˆCCAï¼‰
- æŒæ¡ç‰¹å¾å·¥ç¨‹æŠ€å·§ï¼ˆFilter-Bankï¼‰
- å­¦ä¹ æ¨¡å‹ä¼˜åŒ–æ–¹æ³•ï¼ˆä¸»åŠ¨å­¦ä¹ ï¼‰
- äº†è§£ä¿¡å·å¤„ç†åŸºç¡€

#### èƒ½åŠ›ç›®æ ‡
- èƒ½å¤Ÿè¿›è¡Œç®—æ³•å¯¹æ¯”å®éªŒ
- èƒ½å¤Ÿåˆ†æå’Œå¯è§†åŒ–å®éªŒæ•°æ®
- èƒ½å¤Ÿè¯†åˆ«å’Œè§£å†³æ€§èƒ½ç“¶é¢ˆ
- èƒ½å¤Ÿç¼–å†™ç§‘ç ”çº§æ–‡æ¡£

### 2.3 æ ¸å¿ƒæŠ€æœ¯æ·±åº¦è§£æ

#### 2.3.1 å…¸å‹ç›¸å…³åˆ†æï¼ˆCCAï¼‰

**ç†è®ºåŸºç¡€ï¼š**

CCAæ˜¯ä¸€ç§å¤šå…ƒç»Ÿè®¡æ–¹æ³•ï¼Œç”¨äºæ‰¾åˆ°ä¸¤ç»„å˜é‡ä¹‹é—´çš„æœ€å¤§ç›¸å…³æ€§ã€‚åœ¨SSVEPä¸­ï¼š
- ç¬¬ä¸€ç»„å˜é‡ï¼š6é€šé“EEGä¿¡å·
- ç¬¬äºŒç»„å˜é‡ï¼šå‚è€ƒæ­£å¼¦æ³¢ï¼ˆsin/cosï¼‰

**æ•°å­¦å…¬å¼ï¼š**

```
ç›®æ ‡ï¼šmax Ï = corr(XÂ·a, YÂ·b)

å…¶ä¸­ï¼š
X âˆˆ â„^(nÃ—p): EEGä¿¡å·çŸ©é˜µ (nä¸ªé‡‡æ ·ç‚¹, p=6é€šé“)
Y âˆˆ â„^(nÃ—q): å‚è€ƒä¿¡å·çŸ©é˜µ (nä¸ªé‡‡æ ·ç‚¹, q=4è°æ³¢)
a âˆˆ â„^p, b âˆˆ â„^q: å…¸å‹ç›¸å…³å‘é‡

æ±‚è§£ï¼š
(C_xx^(-1) C_xy C_yy^(-1) C_yx) a = Î»Â² a

Ï = âˆšÎ»_max  # æœ€å¤§ç‰¹å¾å€¼çš„å¹³æ–¹æ ¹
```

**Pythonå®ç°ï¼š**

```python
import numpy as np
from sklearn.cross_decomposition import CCA

class DirectCCA:
    """åŸºçº¿ç®—æ³•ï¼šç›´æ¥CCA"""
    
    def __init__(self, freqs, fs=250, harmonics=2):
        self.freqs = freqs
        self.fs = fs
        self.harmonics = harmonics
        self.references = self._generate_references()
    
    def _generate_references(self):
        """ç”Ÿæˆå‚è€ƒä¿¡å·"""
        t = np.arange(0, 4, 1/self.fs)  # 4ç§’ä¿¡å·
        refs = {}
        
        for freq in self.freqs:
            signals = []
            for h in range(1, self.harmonics + 1):
                # åŸºé¢‘å’Œè°æ³¢
                signals.append(np.sin(2 * np.pi * h * freq * t))
                signals.append(np.cos(2 * np.pi * h * freq * t))
            refs[freq] = np.column_stack(signals)
        
        return refs
    
    def predict(self, X):
        """
        é¢„æµ‹åˆºæ¿€é¢‘ç‡
        
        å‚æ•°:
            X: (n_samples, n_channels) EEGä¿¡å·
        
        è¿”å›:
            freq_idx: é¢„æµ‹çš„é¢‘ç‡ç´¢å¼•
        """
        cca = CCA(n_components=1)
        correlations = []
        
        for freq in self.freqs:
            Y = self.references[freq]
            
            # CCAè®¡ç®—
            cca.fit(X, Y)
            X_c, Y_c = cca.transform(X, Y)
            
            # å…¸å‹ç›¸å…³ç³»æ•°
            corr = np.corrcoef(X_c[:, 0], Y_c[:, 0])[0, 1]
            correlations.append(corr)
        
        return np.argmax(correlations)
```

**æ•™å­¦è¦ç‚¹ï¼š**

1. **åæ–¹å·®çŸ©é˜µè®¡ç®—**
   ```python
   C_xx = np.cov(X, rowvar=False)
   C_yy = np.cov(Y, rowvar=False)
   C_xy = np.cov(X, Y, rowvar=False)[:p, p:]
   ```

2. **å¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜**
   ```python
   from scipy.linalg import eig
   
   # æ±‚è§£ AÂ·a = Î»Â·BÂ·a
   eigenvalues, eigenvectors = eig(A, B)
   ```

3. **æ•°å€¼ç¨³å®šæ€§**
   - é¿å…çŸ©é˜µæ±‚é€†ï¼šä½¿ç”¨SVDåˆ†è§£
   - æ­£åˆ™åŒ–ï¼šæ·»åŠ å¾®å°å¯¹è§’é¡¹é˜²æ­¢å¥‡å¼‚

#### 2.3.2 æ»¤æ³¢å™¨ç»„CCAï¼ˆFilter-Bank CCAï¼‰

**ç†è®ºåŸºç¡€ï¼š**

å°†ä¿¡å·åˆ†è§£åˆ°å¤šä¸ªé¢‘æ®µï¼ˆå­å¸¦ï¼‰ï¼Œåœ¨æ¯ä¸ªå­å¸¦ç‹¬ç«‹è¿›è¡ŒCCAï¼Œç„¶ååŠ æƒèåˆã€‚è¿™åˆ©ç”¨äº†ä¸åŒé¢‘ç‡æˆåˆ†åœ¨ä¸åŒå­å¸¦çš„èƒ½é‡åˆ†å¸ƒå·®å¼‚ã€‚

**å­å¸¦åˆ’åˆ†ï¼š**

```
åŸå§‹ä¿¡å· (6-90 Hz)
     â†“
â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Theta   â”‚ Alpha  â”‚ Beta-L â”‚ Beta-H â”‚
â”‚ 4-8 Hz  â”‚ 8-12Hz â”‚ 12-20Hzâ”‚ 20-35Hzâ”‚
â”‚ æƒé‡:0.25â”‚ 0.25   â”‚ 0.25   â”‚ 0.25   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚        â”‚        â”‚        â”‚
    CCA      CCA      CCA      CCA
     â”‚        â”‚        â”‚        â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
          åŠ æƒèåˆ
              â†“
          æœ€ç»ˆå¾—åˆ†
```

**Pythonå®ç°ï¼š**

```python
from scipy.signal import butter, filtfilt

class FilterBankCCA(DirectCCA):
    """æ”¹è¿›ç®—æ³•ï¼šæ»¤æ³¢å™¨ç»„CCA"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # å®šä¹‰å­å¸¦
        self.subbands = [
            (4, 8),    # Theta
            (8, 12),   # Alpha
            (12, 20),  # Beta-Low
            (20, 35)   # Beta-High
        ]
        
        # å­å¸¦æƒé‡ï¼ˆå¯å­¦ä¹ ï¼‰
        self.weights = np.array([0.25, 0.25, 0.25, 0.25])
    
    def _bandpass_filter(self, data, lowcut, highcut, order=5):
        """å¸¦é€šæ»¤æ³¢"""
        nyq = 0.5 * self.fs
        low = lowcut / nyq
        high = highcut / nyq
        
        b, a = butter(order, [low, high], btype='band')
        return filtfilt(b, a, data, axis=0)
    
    def predict(self, X):
        """å¤šå­å¸¦é¢„æµ‹"""
        n_freqs = len(self.freqs)
        scores = np.zeros((len(self.subbands), n_freqs))
        
        # åœ¨æ¯ä¸ªå­å¸¦ä¸Šè®¡ç®—CCA
        for i, (low, high) in enumerate(self.subbands):
            X_filtered = self._bandpass_filter(X, low, high)
            
            for j, freq in enumerate(self.freqs):
                Y = self.references[freq]
                
                cca = CCA(n_components=1)
                cca.fit(X_filtered, Y)
                X_c, Y_c = cca.transform(X_filtered, Y)
                
                corr = np.corrcoef(X_c[:, 0], Y_c[:, 0])[0, 1]
                scores[i, j] = corr
        
        # åŠ æƒèåˆ
        final_scores = np.dot(self.weights, scores)
        return np.argmax(final_scores)
```

**æ•™å­¦è¦ç‚¹ï¼š**

1. **å·´ç‰¹æ²ƒæ–¯æ»¤æ³¢å™¨è®¾è®¡**
   ```python
   # æ»¤æ³¢å™¨é˜¶æ•°å½±å“æ€§èƒ½
   order = 5  # è¶Šé«˜è¶Šé™¡å³­ï¼Œä½†è®¡ç®—é‡å¤§
   
   # å½’ä¸€åŒ–é¢‘ç‡
   normalized_freq = freq / (sampling_rate / 2)
   ```

2. **é›¶ç›¸ä½æ»¤æ³¢**
   ```python
   # filtfilt: å‰å‘+åå‘æ»¤æ³¢ï¼Œæ¶ˆé™¤ç›¸ä½å»¶è¿Ÿ
   y = filtfilt(b, a, x)
   
   # å¯¹æ¯”ï¼šlfilteråªå‰å‘æ»¤æ³¢ï¼Œæœ‰ç›¸ä½å»¶è¿Ÿ
   y_delayed = lfilter(b, a, x)
   ```

3. **æƒé‡å­¦ä¹ **
   ```python
   # åœ¨éªŒè¯é›†ä¸Šå­¦ä¹ æœ€ä¼˜æƒé‡
   from scipy.optimize import minimize
   
   def objective(weights, scores, labels):
       predictions = np.argmax(scores.T @ weights, axis=1)
       return -np.mean(predictions == labels)
   
   result = minimize(
       objective,
       x0=[0.25, 0.25, 0.25, 0.25],
       bounds=[(0, 1)] * 4,
       constraints={'type': 'eq', 'fun': lambda w: w.sum() - 1}
   )
   optimal_weights = result.x
   ```

#### 2.3.3 ä»»åŠ¡ç›¸å…³æˆåˆ†åˆ†æï¼ˆTRCAï¼‰

**ç†è®ºåŸºç¡€ï¼š**

TRCAé€šè¿‡æœ€å¤§åŒ–åŒä¸€ç±»åˆ«å†…è¯•æ¬¡ä¹‹é—´çš„åæ–¹å·®ï¼Œæ‰¾åˆ°æœ€ä¼˜çš„ç©ºé—´æ»¤æ³¢å™¨ã€‚è¿™ä¸ªæ»¤æ³¢å™¨èƒ½æå–ä¸ç‰¹å®šåˆºæ¿€é¢‘ç‡æœ€ç›¸å…³çš„è„‘ç”µæˆåˆ†ã€‚

**æ•°å­¦æ¨å¯¼ï¼š**

```
ç›®æ ‡ï¼šmax J(w) = w^T S w / w^T Q w

å…¶ä¸­ï¼š
S: ç±»å†…åæ–¹å·®ï¼ˆbetween-trial covarianceï¼‰
Q: æ€»åæ–¹å·®ï¼ˆæ€»æ–¹å·®ï¼‰

S_k = Î£_{i<j} X_i^k X_j^k^T  # ç¬¬kç±»çš„ç±»å†…åæ–¹å·®
S = Î£_k S_k

æ±‚è§£ï¼šå¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜
S w = Î» Q w
```

**Pythonå®ç°ï¼š**

```python
from scipy.linalg import eigh

class TRCA:
    """ä»»åŠ¡ç›¸å…³æˆåˆ†åˆ†æ"""
    
    def __init__(self, n_components=1):
        self.n_components = n_components
        self.filters = {}
        self.templates = {}
    
    def fit(self, X_train, y_train, freqs):
        """
        è®­ç»ƒTRCAæ¨¡å‹
        
        å‚æ•°:
            X_train: list of (n_samples, n_channels)
            y_train: list of int, é¢‘ç‡æ ‡ç­¾
            freqs: list of float, åˆºæ¿€é¢‘ç‡
        """
        for freq_idx in range(len(freqs)):
            # è·å–å½“å‰é¢‘ç‡çš„æ‰€æœ‰è¯•æ¬¡
            trials = [X for X, y in zip(X_train, y_train) if y == freq_idx]
            
            # è®¡ç®—ç±»å†…åæ–¹å·® S
            S = self._compute_between_trial_covariance(trials)
            
            # è®¡ç®—æ€»åæ–¹å·® Q
            Q = self._compute_total_covariance(trials)
            
            # æ±‚è§£å¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜
            eigenvalues, eigenvectors = eigh(S, Q)
            
            # é€‰æ‹©æœ€å¤§ç‰¹å¾å€¼å¯¹åº”çš„ç‰¹å¾å‘é‡
            idx = np.argsort(eigenvalues)[::-1]
            self.filters[freq_idx] = eigenvectors[:, idx[:self.n_components]]
            
            # è®¡ç®—TRCAæ¨¡æ¿ï¼ˆæŠ•å½±åçš„å¹³å‡ï¼‰
            projected = [trial @ self.filters[freq_idx] for trial in trials]
            self.templates[freq_idx] = np.mean(projected, axis=0)
    
    def _compute_between_trial_covariance(self, trials):
        """è®¡ç®—ç±»å†…åæ–¹å·®"""
        n_channels = trials[0].shape[1]
        S = np.zeros((n_channels, n_channels))
        
        # æ‰€æœ‰è¯•æ¬¡å¯¹ä¹‹é—´çš„åæ–¹å·®
        for i in range(len(trials)):
            for j in range(i + 1, len(trials)):
                S += trials[i].T @ trials[j]
        
        return S
    
    def _compute_total_covariance(self, trials):
        """è®¡ç®—æ€»åæ–¹å·®"""
        # è¿æ¥æ‰€æœ‰è¯•æ¬¡
        X_concat = np.vstack(trials)
        return X_concat.T @ X_concat
    
    def predict(self, X_test):
        """é¢„æµ‹"""
        correlations = []
        
        for freq_idx in self.filters.keys():
            # æŠ•å½±åˆ°TRCAç©ºé—´
            X_projected = X_test @ self.filters[freq_idx]
            
            # ä¸æ¨¡æ¿è®¡ç®—ç›¸å…³æ€§
            corr = np.corrcoef(
                X_projected.flatten(),
                self.templates[freq_idx].flatten()
            )[0, 1]
            
            correlations.append(corr)
        
        return np.argmax(correlations)
```

**æ•™å­¦è¦ç‚¹ï¼š**

1. **å¹¿ä¹‰ç‰¹å¾å€¼åˆ†è§£**
   ```python
   # scipyæä¾›äº†ä¸“é—¨çš„å‡½æ•°
   eigenvalues, eigenvectors = eigh(A, B)
   
   # ç­‰ä»·äºæ±‚è§£
   # A v = Î» B v
   ```

2. **ç©ºé—´æ»¤æ³¢å™¨å¯è§†åŒ–**
   ```python
   import matplotlib.pyplot as plt
   
   # æ˜¾ç¤ºæ»¤æ³¢å™¨æƒé‡ï¼ˆæ‹“æ‰‘å›¾ï¼‰
   plt.imshow(filters.reshape(6, 1), cmap='RdBu_r')
   plt.colorbar()
   plt.title('TRCA Spatial Filter')
   ```

3. **CCA + TRCAèåˆ**
   ```python
   def combined_predict(X):
       cca_score = cca_model.predict(X)
       trca_score = trca_model.predict(X)
       
       # åŠ æƒèåˆ
       final_score = 0.6 * cca_score + 0.4 * trca_score
       return final_score
   ```

#### 2.3.4 ä¸»åŠ¨å­¦ä¹ ï¼ˆActive Learningï¼‰

**ç†è®ºåŸºç¡€ï¼š**

ä¸»åŠ¨å­¦ä¹ é€šè¿‡æ™ºèƒ½é€‰æ‹©æœ€æœ‰ä»·å€¼çš„æ ·æœ¬è¿›è¡Œæ ‡æ³¨ï¼Œå‡å°‘æ ‡æ³¨æˆæœ¬ã€‚åœ¨æœ¬é¡¹ç›®ä¸­ï¼Œä½¿ç”¨Marginé‡‡æ ·ç­–ç•¥ã€‚

**Marginé‡‡æ ·ï¼š**

```
å®šä¹‰ï¼šMargin = score_top1 - score_top2

è§£é‡Šï¼š
- Marginå¤§ â†’ æ¨¡å‹ç¡®å®š
- Marginå° â†’ æ¨¡å‹çŠ¹è±«ï¼ˆæ ·æœ¬åœ¨å†³ç­–è¾¹ç•Œé™„è¿‘ï¼‰

ç­–ç•¥ï¼šä¼˜å…ˆæ ‡æ³¨Marginæœ€å°çš„æ ·æœ¬
```

**å®ç°æµç¨‹ï¼š**

```
1. åˆå§‹è®­ç»ƒé›†ï¼šå…¨éƒ¨48ä¸ªæ ·æœ¬
   â†“
2. è®­ç»ƒåŸºç¡€æ¨¡å‹
   â†“
3. åœ¨æœªæ ‡æ³¨é›†é¢„æµ‹ï¼Œè®¡ç®—Margin
   â†“
4. é€‰æ‹©Marginæœ€å°çš„12ä¸ªæ ·æœ¬
   â†“
5. äººå·¥æ ‡æ³¨ï¼ˆæˆ–ä½¿ç”¨çœŸå®æ ‡ç­¾ï¼‰
   â†“
6. æ‰©å……è®­ç»ƒé›†ï¼š48 + 12 = 60
   â†“
7. é‡æ–°è®­ç»ƒ
   â†“
8. é‡å¤æ­¥éª¤3-7ï¼ˆç¬¬äºŒè½®é€‰8ä¸ªï¼‰
   â†“
9. æœ€ç»ˆè®­ç»ƒé›†ï¼š68ä¸ªæ ·æœ¬
```

**Pythonå®ç°ï¼š**

```python
class ActiveLearner:
    """ä¸»åŠ¨å­¦ä¹ å™¨"""
    
    def __init__(self, model):
        self.model = model
        self.labeled_indices = []
        self.unlabeled_indices = []
    
    def calculate_margin(self, X):
        """è®¡ç®—ä¸ç¡®å®šæ€§ï¼ˆMarginï¼‰"""
        scores = []
        
        for x in X:
            # è·å–æ‰€æœ‰ç±»åˆ«çš„å¾—åˆ†
            class_scores = self.model.predict_proba(x)
            
            # æ’åº
            sorted_scores = np.sort(class_scores)[::-1]
            
            # Margin = top1 - top2
            margin = sorted_scores[0] - sorted_scores[1]
            scores.append(margin)
        
        return np.array(scores)
    
    def query(self, n_samples):
        """
        æŸ¥è¯¢æœ€æœ‰ä»·å€¼çš„æ ·æœ¬
        
        å‚æ•°:
            n_samples: è¦æŸ¥è¯¢çš„æ ·æœ¬æ•°
        
        è¿”å›:
            selected_indices: é€‰ä¸­çš„æ ·æœ¬ç´¢å¼•
        """
        X_unlabeled = self.X[self.unlabeled_indices]
        
        # è®¡ç®—Margin
        margins = self.calculate_margin(X_unlabeled)
        
        # é€‰æ‹©Marginæœ€å°çš„æ ·æœ¬
        uncertain_idx = np.argsort(margins)[:n_samples]
        selected_indices = [self.unlabeled_indices[i] for i in uncertain_idx]
        
        return selected_indices, margins[uncertain_idx]
    
    def update(self, new_indices, new_labels):
        """æ›´æ–°è®­ç»ƒé›†"""
        self.labeled_indices.extend(new_indices)
        self.unlabeled_indices = [
            i for i in range(len(self.X))
            if i not in self.labeled_indices
        ]
        
        # é‡æ–°è®­ç»ƒ
        X_train = self.X[self.labeled_indices]
        y_train = self.y[self.labeled_indices]
        self.model.fit(X_train, y_train)
```

**å®éªŒç»“æœåˆ†æï¼š**

```
ç¬¬1è½®ä¸»åŠ¨å­¦ä¹ ï¼š
- é€‰æ‹©æ ·æœ¬ï¼š12ä¸ªï¼ˆMarginæœ€å°ï¼‰
- Marginç»Ÿè®¡ï¼šmin=0.0026, avg=0.1609, max=0.3158
- è®­ç»ƒé›†è§„æ¨¡ï¼š48 â†’ 60
- å‡†ç¡®ç‡æå‡ï¼š97.92% â†’ 99.58%

ç¬¬2è½®ä¸»åŠ¨å­¦ä¹ ï¼š
- é€‰æ‹©æ ·æœ¬ï¼š8ä¸ª
- Marginç»Ÿè®¡ï¼šmin=0.0593, avg=0.1943, max=0.3242
- è®­ç»ƒé›†è§„æ¨¡ï¼š60 â†’ 68
- å‡†ç¡®ç‡æå‡ï¼š99.58% â†’ 100.00%

å…³é”®å‘ç°ï¼š
1. Marginçš„æœ€å°å€¼å’Œå¹³å‡å€¼éƒ½ä¸Šå‡
   â†’ å›°éš¾æ ·æœ¬é€æ¸è¢«è¦†ç›–
2. ä»…ç”¨20ä¸ªé¢å¤–æ ‡æ³¨ï¼ˆ42%ï¼‰è¾¾åˆ°100%
   â†’ ä¸»åŠ¨å­¦ä¹ é«˜æ•ˆ
```

**æ•™å­¦è¦ç‚¹ï¼š**

1. **ä¸ç¡®å®šæ€§åº¦é‡æ–¹æ³•**
   ```python
   # 1. Marginé‡‡æ ·ï¼ˆæœ¬é¡¹ç›®ä½¿ç”¨ï¼‰
   margin = top1_score - top2_score
   
   # 2. ç†µé‡‡æ ·
   entropy = -Î£ p_i log(p_i)
   
   # 3. æ–¹å·®é‡‡æ ·ï¼ˆå§”å‘˜ä¼šæ–¹æ³•ï¼‰
   variance = Var(predictions_from_different_models)
   ```

2. **æ ‡æ³¨é¢„ç®—åˆ†é…**
   ```python
   # ç­–ç•¥1ï¼šå›ºå®šæ‰¹æ¬¡
   batches = [12, 8, 8, ...]
   
   # ç­–ç•¥2ï¼šåŠ¨æ€è°ƒæ•´ï¼ˆåŸºäºå‡†ç¡®ç‡æå‡ï¼‰
   if accuracy_gain < threshold:
       batch_size = batch_size // 2
   ```

3. **åœæ­¢æ¡ä»¶**
   ```python
   # æ¡ä»¶1ï¼šè¾¾åˆ°ç›®æ ‡å‡†ç¡®ç‡
   if accuracy >= target_accuracy:
       stop()
   
   # æ¡ä»¶2ï¼šMarginä¸å†é™ä½
   if min_margin > previous_min_margin:
       stop()
   
   # æ¡ä»¶3ï¼šé¢„ç®—ç”¨å°½
   if labeled_count >= budget:
       stop()
   ```

### 2.4 è¯¾ç¨‹æ•™å­¦è®¾è®¡

#### è¯¾æ—¶1-2: ç®—æ³•åŸºç¡€ï¼ˆ2è¯¾æ—¶ï¼‰

**ç†è®ºè®²è§£ï¼š**
1. CCAæ•°å­¦åŸç†
2. æ»¤æ³¢å™¨è®¾è®¡åŸºç¡€
3. ç‰¹å¾å€¼åˆ†è§£

**å®è·µä»»åŠ¡ï¼š**
```python
# ä»»åŠ¡1ï¼šå®ç°åŸºç¡€CCA
def canonical_correlation_analysis(X, Y):
    """
    è®¡ç®—Xå’ŒYçš„å…¸å‹ç›¸å…³ç³»æ•°
    
    è¦æ±‚ï¼š
    1. æ‰‹åŠ¨å®ç°ï¼ˆä¸ç”¨sklearnï¼‰
    2. è®¡ç®—åæ–¹å·®çŸ©é˜µ
    3. æ±‚è§£å¹¿ä¹‰ç‰¹å¾å€¼é—®é¢˜
    4. è¿”å›æœ€å¤§ç›¸å…³ç³»æ•°
    """
    # TODO: å®ç°
    pass

# ä»»åŠ¡2ï¼šæ»¤æ³¢å™¨è®¾è®¡
def design_bandpass_filter(lowcut, highcut, fs, order=5):
    """
    è®¾è®¡å¸¦é€šæ»¤æ³¢å™¨å¹¶å¯è§†åŒ–é¢‘ç‡å“åº”
    
    è¦æ±‚ï¼š
    1. ä½¿ç”¨scipy.signal.butter
    2. ç»˜åˆ¶é¢‘ç‡å“åº”æ›²çº¿
    3. æµ‹è¯•ä¸åŒé˜¶æ•°çš„å½±å“
    """
    # TODO: å®ç°
    pass
```

#### è¯¾æ—¶3-4: ç®—æ³•ä¼˜åŒ–ï¼ˆ2è¯¾æ—¶ï¼‰

**å®éªŒå¯¹æ¯”ï¼š**
1. DirectCCA vs Filter-Bank CCA
2. æ€§èƒ½æå‡åˆ†æ
3. å¯è§†åŒ–ç»“æœ

**å®è·µä»»åŠ¡ï¼š**
```python
# ç»¼åˆå®éªŒï¼šç®—æ³•å¯¹æ¯”
def compare_algorithms(X_train, y_train, X_test, y_test):
    """
    å¯¹æ¯”ä¸‰ç§ç®—æ³•æ€§èƒ½
    
    è¦æ±‚ï¼š
    1. å®ç°DirectCCA, FilterBankCCA, TRCA
    2. è®¡ç®—å‡†ç¡®ç‡ã€æ··æ·†çŸ©é˜µ
    3. ç»˜åˆ¶æ€§èƒ½å¯¹æ¯”å›¾
    4. åˆ†æä¼˜ç¼ºç‚¹
    
    è¾“å‡ºï¼š
    - å‡†ç¡®ç‡è¡¨æ ¼
    - æ··æ·†çŸ©é˜µçƒ­åŠ›å›¾
    - æ¯ç±»å‡†ç¡®ç‡æŸ±çŠ¶å›¾
    - æ€§èƒ½åˆ†ææŠ¥å‘Šï¼ˆ500å­—ï¼‰
    """
    # TODO: å®ç°
    pass
```

#### è¯¾æ—¶5-6: ä¸»åŠ¨å­¦ä¹ ï¼ˆ2è¯¾æ—¶ï¼‰

**é¡¹ç›®å®æˆ˜ï¼š**
å®ç°å®Œæ•´çš„ä¸»åŠ¨å­¦ä¹ æµç¨‹

**è¯„åˆ†æ ‡å‡†ï¼š**
| é¡¹ç›® | åˆ†å€¼ | è¦æ±‚ |
|------|------|------|
| ç®—æ³•å®ç° | 40 | æ­£ç¡®å®ç°Marginé‡‡æ · |
| å®éªŒè®¾è®¡ | 30 | åˆç†çš„å®éªŒæµç¨‹ |
| æ•°æ®åˆ†æ | 20 | è¯¦ç»†çš„ç»“æœåˆ†æ |
| æ–‡æ¡£è´¨é‡ | 10 | æ¸…æ™°çš„å®éªŒæŠ¥å‘Š |

### 2.5 æ•™å­¦èµ„æº

#### æ•°æ®é›†

```
data/
â”œâ”€â”€ D1.csv              # è®­ç»ƒé›†ï¼ˆ48ä¸ªæ ·æœ¬ï¼‰
â”œâ”€â”€ D2.csv              # æµ‹è¯•é›†ï¼ˆ48ä¸ªæ ·æœ¬ï¼‰
â””â”€â”€ README.md           # æ•°æ®è¯´æ˜
```

**æ•°æ®æ ¼å¼ï¼š**
```
åˆ—1-6: è„‘ç”µé€šé“ï¼ˆCP3, CPZ, CP4, PO3, POZ, PO4ï¼‰
åˆ—7: taskIDï¼ˆä»»åŠ¡æ®µæ ‡è¯†ï¼‰
åˆ—8: stimIDï¼ˆåˆºæ¿€é¢‘ç‡ç¼–å·ï¼Œ0-7å¯¹åº”8-15Hzï¼‰
```

#### è¯„ä¼°è„šæœ¬

```python
# evaluate.py
def evaluate_model(y_true, y_pred, class_names):
    """å®Œæ•´çš„è¯„ä¼°æŒ‡æ ‡"""
    from sklearn.metrics import (
        accuracy_score,
        classification_report,
        confusion_matrix
    )
    
    # å‡†ç¡®ç‡
    acc = accuracy_score(y_true, y_pred)
    print(f"Overall Accuracy: {acc:.2%}")
    
    # åˆ†ç±»æŠ¥å‘Š
    print("\nClassification Report:")
    print(classification_report(
        y_true, y_pred,
        target_names=class_names
    ))
    
    # æ··æ·†çŸ©é˜µ
    cm = confusion_matrix(y_true, y_pred)
    plot_confusion_matrix(cm, class_names)
    
    # æ¯ç±»å‡†ç¡®ç‡
    class_acc = cm.diagonal() / cm.sum(axis=1)
    plot_per_class_accuracy(class_acc, class_names)
```

### 2.6 æ‰©å±•é˜…è¯»

1. **ç»å…¸è®ºæ–‡**
   - Hotelling H. (1936). *Relations Between Two Sets of Variates*
   - Chen X. et al. (2017). *Filter Bank Canonical Correlation Analysis for Multimodal SSVEP-based BCIs*

2. **å¼€æºé¡¹ç›®**
   - pyRiemann: Python Riemannian Geometryåº“
   - MNE-Python: è„‘ç”µä¿¡å·å¤„ç†

3. **åœ¨çº¿è¯¾ç¨‹**
   - Coursera: Machine Learning (Andrew Ng)
   - Fast.ai: Practical Deep Learning

---


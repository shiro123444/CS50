---
date: 2025-11-24T17:42:00
tags:
  - cs50
  - 花凉的小秘密
aliases:
  - Ciallo～(∠・ω< )⌒★
---
 # 第一部分：IDE 与 命令行 (The Terminal)

CS50 使用基于云端的 VS Code (Codespaces)。

### 1. 源代码 vs 机器码

- **Source Code (源代码):** 人类可读的代码（如 `hello.c`）。
    
- **Machine Code (机器码):** 计算机可读的二进制指令（0 和 1）。
    
- **Compiler (编译器):** 将源代码转换为机器码的程序。在 CS50 中，我们使用 `clang` 或 `make`。
    

### 2. 常用 Linux 命令 (在终端中使用)

终端（Terminal）是我们与操作系统直接对话的窗口。

- `ls` (list): 列出当前文件夹下的所有文件。
    
- `cd <folder>` (change directory): 进入某个文件夹。
    
    - `cd ..`: 返回上一级目录。
        
- `mkdir <name>` (make directory): 创建新文件夹。
    
- `rm <file>` (remove): 删除文件（小心！通常不可恢复）。
    
- `cp <source> <dest>`: 复制文件。
    
- `mv <source> <dest>`: 移动或重命名文件。
    
- `code <file>`: 在编辑器中打开或创建文件。
 [^1] ![典](/images/典.png)
 <!-- MISSING IMAGE: ![Pasted image](/images/pasted-image-20251124-181501.png) -->   

<!-- 把下面这行写成注释/普通文字，避免被 VitePress 当作链接定义解析为相对链接导致死链 -->
注：参考文献（非链接） — 具体来源可在必要时补充 URL 或外部引用。

# 第二部分：第一个C语言程序----hello world
这是最基础的 C 程序结构：

```c
#include <stdio.h>

int main(void)
{
    printf("hello, world\n");
}
```

### 代码详解

1. **`#include <stdio.h>`**:
    
    - 告诉编译器引入 **Standard Input/Output** (标准输入输出) 库。
        
    - 没有它，计算机不知道 `printf` 是什么。
        
2. **`int main(void)`**:
    
    - 程序的**入口点 (Entry Point)**。当程序启动时，系统会寻找 `main` 函数并执行其中的代码。
        
    - `{}` 花括号代表代码块的开始和结束。
        
3. **`printf("...");`**:
    
    - 将文本打印到屏幕上的函数。
        
    - `\n`: 转义字符 (Escape Character)，代表**换行 (New Line)**。
        
4. **`;` (分号)**:
    
    - 语句的结束符。C 语言中几乎每行指令结束都要加分号（就像句子后的句号）。
        

### 如何运行？

在终端中输入：

1. `make hello` (编译 `hello.c` 生成可执行文件 `hello`)
    
2. `./hello` (执行当前目录下的 `hello` 程序)


# 第三部分：变量与数据类型 (Variables & Types)
C 语言是**静态类型 (Statically Typed)** 语言，这意味着创建变量时必须明确告诉计算机它存的是什么类型的数据。
## 一. 数据类型
### 1.1.常见数据类型
- `int`: 整数 (Integer)，如 `1`, `-5`, `42`。通常占 4 bytes (32 bits)。
    
- `float`: 浮点数 (Real number)，带小数点的数。
    
- `char`: 单个字符 (Character)，用单引号，如 `'a'`, `'Z'`, `'?'`。
    
- `string`: 字符串 (CS50 自定义类型)，一串字符，用双引号，如 `"David"`。
    
- `bool`: 布尔值 (Boolean)，只有 `true` 或 `false`。
    
- `long`: 更大的整数（64 bits）。
    
- `double`: 精度更高的浮点数。
### 1.2. 格式化说明符 (Format Codes)
在使用 `printf` 时，需要用占位符来打印变量：

- `%s` : 字符串 (string)
    
- `%i` 或 `%d` : 整数 (int)
    
- `%f` : 浮点数 (float)
    
- `%c` : 字符 (char)
    

**示例：**

```c
string name = "Maria";
int age = 20;
printf("My name is %s and I am %i years old.\n", name, age);
```

### 1.3. CS50 库

为了降低入门难度，CS50 提供了 `<cs50.h>` 库，包含处理用户输入的函数：

- `get_string("What's your name? ");`
    
- `get_int("Input a number: ");`


## 二.构造类型
构造类型是C语言实现复杂数据结构的核心，由基本类型组合而成。
### 2.1 数组（Array）
数组用于存储同类型、固定数量的元素。

```c
// 声明与初始化
int scores[5] = {90, 85, 88, 92, 76};

// 访问与遍历
for (int i = 0; i < 5; i++)
{
    printf("scores[%i] = %i\n", i, scores[i]);
}

// 未显式初始化的元素默认值未定义（需谨慎）
int a[3]; // 使用前应赋值
```

要点：
- 数组长度在编译期确定；越界访问会导致未定义行为（严重错误）。
- `sizeof(scores) / sizeof(scores[0])` 可计算数组元素个数（在同一作用域内）。

### 2.2 字符串与字符数组（String vs char[]）
在CS50库中有 `string` 类型，但在标准C中，字符串是以 `\0` 结尾的字符数组。

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string name = get_string("Name: ");      // CS50 的 string
    printf("Hello, %s!\n", name);

    // 标准C的字符串（字符数组，末尾有 '\0'）
    char msg[] = "CS50";                     // 自动添加终止符
    printf("len(msg) = %lu\n", strlen(msg)); // 结果为 4
}
```

要点：
- `strlen` 计算不含 `\0` 的字符数；`\0` 是字符串结束标记。
- 字符数组容量必须足够容纳内容与终止符；避免溢出。

### 2.3 结构体（struct）
结构体用于将不同类型的数据组合在一起，构造自定义记录类型。

```c
typedef struct
{
    string name;
    int age;
} Person;

int main(void)
{
    Person p = { .name = "Maria", .age = 20 };
    printf("%s is %i years old.\n", p.name, p.age);
}
```

### 2.4 类型别名（typedef）
用 `typedef` 给类型起别名，提升可读性：

```c
typedef unsigned long ulong;
ulong x = 42;
```

### 2.5 枚举（enum）
枚举是有限离散取值的类型（更语义化）：

```c
typedef enum { MON, TUE, WED, THU, FRI, SAT, SUN } Day;

Day today = MON;
if (today == MON)
{
    printf("Start of the week!\n");
}
```

---
## 三. 指针（Pointer）
指针是**保存内存地址**的变量。两个关键运算符：
- `&`（地址运算符）：取得变量的地址。
- `*`（解引用）：通过地址访问该地址处的数据。

```c
#include <stdio.h>

int main(void)
{
    int x = 42;
    int *px = &x;           // px 保存 x 的地址
    printf("x = %i\n", x);
    printf("*px = %i\n", *px); // 解引用得到 42

    *px = 100;               // 通过指针修改原变量
    printf("x = %i\n", x);  // 现在为 100

    // 空指针（NULL）用于指示“无有效地址”
    int *pnull = NULL;
    // 切勿对 NULL 解引用：*pnull —— 未定义行为
}
```

要点：
- `string` 在 CS50 中本质是 `char*`；标准 C 字符串以 `\0` 结尾。
- 数组名在表达式中常“衰减”为指向首元素的指针；指针算术需谨慎，避免越界。
- 指向指针的指针：`int **pp = &px;`；多级间接访问用于处理复杂数据结构。

## 四. 空类型（void）
- `void` 作为函数返回类型：表示**不返回值**。
- `void` 作为参数列表：`void f(void)` 表示**不接收参数**。
- `void*`：通用指针类型，可指向任意数据；**必须在使用前强制转换**成具体类型。

```c
void greet(void)
{
    printf("Hello!\n");
}

void print_any(void *p)
{
    // 使用前需要转换为具体类型
    int *pi = (int *)p;
    printf("value = %i\n", *pi);
}
```

## 五.其他
### 1. 类型转换与溢出（Casting & Overflow）
- 显式转换（cast）：`(float) 5 / 2` 得到 2.5；避免整数截断。
- 隐式转换：表达式中不同类型参与计算会进行提升（如整型提升）。
- 溢出：类型范围不足导致结果回绕或截断，属于未定义或实现定义行为，需谨慎。

```c
unsigned char b = 255; // 最大值
b = b + 1;             // 可能变成 0（回绕）
printf("b = %u\n", b);
```

### 2. 有符号与无符号（Signed vs Unsigned）
- `signed` 可表示负数；`unsigned` 仅表示非负数，范围不同。
- 比较不同符号类型可能触发隐式转换，导致意外结果；建议统一类型后再比较。

```c
int si = -1;
unsigned int ui = 1;
// 警示：si 与 ui 比较时会发生转换，结果可能出乎意料
printf("%i < %u ? %s\n", si, ui, (si < (int)ui) ? "true" : "false");
```

### 3. 尺寸与范围（Size & Range）
- 使用 `sizeof(type)` 获取字节数；不同平台实现可能不同。
- 了解类型范围有助于选择合适类型存储数据（如计数用 `size_t`）。

```c
printf("sizeof(int) = %zu\n", sizeof(int));
printf("sizeof(long) = %zu\n", sizeof(long));

## 三. 变量（Variables）
- 声明 vs 定义：声明告诉编译器变量的类型与名字；定义分配存储空间。
- 初始化：C 中**未初始化的局部变量值不确定**，需显式赋值。
- 作用域（Scope）：变量仅在其所在的代码块 `{}` 内可见。
- 生命周期（Lifetime）：自动变量在离开作用域后消失；`static` 局部变量在函数调用间保留值。
- 存储类（Storage Class）：`auto`（默认）、`static`（静态存储期）、`extern`（声明外部变量）。
- 常量：`const` 防止修改；宏 `#define` 在预处理阶段替换，缺少类型检查。

```c
// static 局部变量示例：累计调用次数
int hit(void)
{
    static int count = 0; // 只初始化一次
    return ++count;
}

// extern 示例（跨文件）：
// file1.c: int g = 0;
// file2.c: extern int g; // 使用外部定义的变量
```

##### **命名建议：语义清晰、使用小写与下划线或小驼峰，避免一字母变量（除非循环计数）。**
-------

# 第四部分：运算符与算术 (Operators) —— 超级详细

本节系统梳理 C 的运算符与算术规则，配合示例与常见坑，帮助你写出正确且可维护的数值逻辑。

## 4.1 算术运算符（Arithmetic）
- `+` 加法，`-` 减法，`*` 乘法，`/` 除法，`%` 取余（remainder）。
- 一元运算：`-x`（取负），`+x`（常与显式转换结合）。

示例：
```c
int a = 7, b = 3;
printf("a + b = %d\n", a + b);  // 10
printf("a - b = %d\n", a - b);  // 4
printf("a * b = %d\n", a * b);  // 21
printf("a / b = %d\n", a / b);  // 2（整数除法，截断小数）
printf("a %% b = %d\n", a % b);  // 1（余数，注意转义 %%）
```

## 4.2 整数除法与取余的细节
- C99/11 规定：整数除法按**向零（truncation toward zero）**截断。
- 余数关系：`a == (a / b) * b + (a % b)`；`a % b` 与 `a` 同号（`b != 0`）。

示例（负数）：
```c
printf("-7 / 3 = %d\n", -7 / 3);  // -2（向零）
printf("-7 %% 3 = %d\n", -7 % 3);  // -1（与被除数同号）
```

## 4.3 自增/自减与复合赋值
- 复合赋值：`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`、`|=`。
- 自增/自减：`i++`、`++i`、`i--`、`--i`。
  - 前缀 `++i`：先加后用；后缀 `i++`：先用后加。

示例：
```c
int i = 1;
printf("%d\n", i++); // 打印 1，i 变为 2
printf("%d\n", ++i); // i 先变为 3，再打印 3
```

## 4.4 比较与逻辑（Relational & Logical）
- 比较：`==`、`!=`、`<`、`<=`、`>`、`>=`。
- 逻辑：`&&` 与，`||` 或，`!` 非。
- 短路规则：`&&` 左侧为 `false` 则右侧不求值；`||` 左侧为 `true` 则右侧不求值（常用于防御空指针）。

示例：
```c
char *p = NULL;
if (p != NULL && p[0] == 'A') { /* 安全：右侧不被求值 */ }
```

## 4.5 位运算（Bitwise）
- 与 `&`，或 `|`，异或 `^`，取反 `~`。
- 左移 `<<`（乘以 2 的幂），右移 `>>`（除以 2 的幂）。
  - 对无符号类型右移为**逻辑右移**（高位补 0）。
  - 对有符号类型右移可能为**算术右移**（实现定义，补符号位），建议对位运算使用无符号类型（如 `unsigned int`、`uint32_t`）。

示例与掩码：
```c
unsigned int flags = 0;
const unsigned int READ = 1u << 0;  // 0001
const unsigned int WRITE = 1u << 1; // 0010

flags |= READ;               // 置位
flags |= WRITE;
printf("has READ? %d\n", (flags & READ) != 0);

flags &= ~READ;              // 清位
printf("has READ? %d\n", (flags & READ) != 0);

unsigned int x = 0b0001u;
printf("x << 2 = %u\n", x << 2); // 0100 (4)
```

## 4.6 运算符优先级与结合性（Precedence & Associativity）
- 优先级（常见从高到低）：
  - 括号 `( )` > 一元 `! ~ ++ -- (type)` > 乘除模 `* / %` > 加减 `+ -`
  - 位移 `<< >>` > 关系 `< <= > >=` > 相等 `== !=`
  - 位与 `&` > 位异或 `^` > 位或 `|`
  - 逻辑与 `&&` > 逻辑或 `||`
  - 条件 `?:` > 赋值 `= += -= *= /= %= <<= >>= &= ^= |=`
- 结合性：多数是左结合；一元与赋值、条件为右结合。
- 建议：当不确定优先级时用括号明确意图，避免歧义。

## 4.7 整型提升与常规算术转换（Integer Promotion & Usual Arithmetic Conversions）
- 整型提升：`char`、`short` 在表达式中提升为 `int`（或 `unsigned int`）。
- 常规算术转换：不同类型参与计算时按规则对齐（例如 `int` 与 `double` → 转为 `double` 计算）。

示例：
```c
char c = 200;           // 可能溢出，具体取值实现相关
int r = c + 1;          // c 提升为 int 再参与计算
double d = 5 + 2.5;     // 转为 double 计算，结果 7.5
```

## 4.8 浮点数（Floating Point）与数学库
- 浮点不可精确表示所有小数，运算存在误差；比较时应使用“近似相等”。
- 常用函数（`<math.h>`）：`fabs`、`ceil`、`floor`、`round`、`pow`、`sqrt` 等。
- 在某些环境需链接数学库：`clang foo.c -lm`（CS50 的 `make` 通常已配置）。

示例：
```c
#include <math.h>
double x = 0.1 + 0.2;                // 不一定精确等于 0.3
if (fabs(x - 0.3) < 1e-9) { /* 近似相等 */ }
```

## 4.9 顺序与副作用（Order of Evaluation & Side Effects）
- 由于未指定的求值顺序，表达式如 `i++ + i++` 是**未定义行为**，不要写。
- 依赖短路与明确括号，拆分复杂表达式，提高可读性与安全性。

## 4.10 常见坑与未定义行为（UB）
- 除以 0 或对 0 取余：运行期错误或未定义行为。
- 有符号整数溢出：未定义行为；无符号按模 2^n 回绕。
- 位移：对负数或位数超界（≥ 位宽）为未定义或实现定义；优先使用无符号并检查位数。
- 浮点比较：用阈值比较而非直接 `==`。
- 隐式类型转换：不同符号类型比较可能产生意外结果，建议显式转换统一类型。

小结建议
- 当不确定优先级，就加括号；当表达式复杂，就拆分。
- 用“近似相等”比较浮点；对整数边界与符号类型保持敏感。
- 对位运算使用无符号类型；对除/模检查分母不为 0。
----
# 第五部分：控制流 (Control Flow)
## 1. 条件语句（Conditionals）

### 1.1 `if` / `else if` / `else`

```c
int x = 0;
scanf("%d", &x);
if (x > 0) {
    printf("positive\n");
} else if (x == 0) {
    printf("zero\n");
} else {
    printf("negative\n");
}
```

要点：
- C 的“真值”：非零为真，零为假；建议用清晰的比较表达式。
- 使用括号与分支块，避免单行省略大括号引入的维护风险。
- 组合条件时优先短路逻辑 `&&` 与 `||`，并加括号明确意图。

### 1.2 条件运算符 `?:`

```c
int absx = (x >= 0) ? x : -x;
printf("%d\n", absx);
```

要点：
- 返回值类型按常规算术转换对齐；避免在 `?:` 中放入有副作用的表达式。
- 当分支较长或含复杂副作用时优先使用显式 `if/else`。

### 1.3 组合条件与防御式写法

```c
int a = 0, b = 0;
scanf("%d %d", &a, &b);
if (b != 0 && a % b == 0) {
    printf("divisible\n");
} else {
    printf("not divisible\n");
}
```

要点：
- 利用短路：在访问可能无效的数据前先判断其有效性。
- 将复杂条件拆分为多个中间变量，提升可读性与可测试性。

## 2. 选择语句（switch）

### 2.1 基本用法与 `break`

```c
int grade = 0;
scanf("%d", &grade);
switch (grade / 10) {
    case 10:
    case 9:
        printf("A\n");
        break;
    case 8:
        printf("B\n");
        break;
    case 7:
        printf("C\n");
        break;
    case 6:
        printf("D\n");
        break;
    default:
        printf("F\n");
        break;
}
```

要点：
- `case` 采用常量表达式；未写 `break` 将贯穿到下一分支。
- `default` 作为兜底分支，位置不固定但建议置于末尾。

### 2.2 配合枚举类型

```c
typedef enum { MON, TUE, WED, THU, FRI, SAT, SUN } Day;
Day d = WED;
switch (d) {
    case MON: printf("Mon\n"); break;
    case TUE: printf("Tue\n"); break;
    case WED: printf("Wed\n"); break;
    case THU: printf("Thu\n"); break;
    case FRI: printf("Fri\n"); break;
    default: printf("Weekend\n"); break;
}
```

要点：
- `switch` 支持整数、字符与枚举类型；不支持浮点与字符串。
- 在 `case` 分支内声明变量时使用 `{}` 形成独立作用域。

```c
int x = 0;
scanf("%d", &x);
switch (x) {
    case 0: {
        int y = 1;
        printf("%d\n", y);
        break;
    }
    default:
        printf("other\n");
}
```

## 3. 跳转语句（Jump Statements）

### 3.1 `break` 与 `continue`

```c
for (int i = 0; i < 10; i++) {
    if (i == 5) break;
    printf("%d ", i);
}
printf("\n");

for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) continue;
    printf("%d ", i);
}
printf("\n");
```

要点：
- `break` 退出最近的循环或 `switch`；`continue` 跳到最近循环的下一次迭代。
- 在嵌套环境中，`break/continue` 的作用域仅限最内层。

### 3.2 `return`

```c
int index_of(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) return i;
    }
    return -1;
}
```

要点：
- 及时 `return` 能简化控制流；确保所有路径均有明确返回值。

### 3.3 `goto` 与标签

```c
int found = 0;
for (int i = 0; i < 100; i++) {
    for (int j = 0; j < 100; j++) {
        if (i * j == 1234) {
            found = 1;
            goto done;
        }
    }
}
done:
if (found) printf("ok\n");
```

要点：
- `goto` 可用于从深层循环中快速跳出；建议克制使用并保持标签少且语义明确。

## 4. 循环语句（Loops）

### 4.1 `while`

```c
int i = 0;
while (i < 3) {
    printf("%d\n", i);
    i++;
}
```

### 4.2 `do ... while`

```c
int n = 0;
do {
    printf("%d\n", n);
    n++;
} while (n < 3);
```

### 4.3 `for`

```c
for (int i = 0; i < 3; i++) {
    printf("%d\n", i);
}
```

要点：
- 选择适合的循环：已知迭代次数用 `for`，基于条件用 `while`，至少执行一次用 `do...while`。
- 防止死循环：确保循环变量被更新，退出条件可达。

### 4.4 常见模式

读取直到 EOF：

```c
int c;
while ((c = getchar()) != EOF) {
    putchar(c);
}
```

按行读取数字：

```c
int x;
while (scanf("%d", &x) == 1) {
    printf("%d\n", x);
}
```

使用无符号索引：

```c
for (size_t i = 0; i < 10; i++) {
    printf("%zu\n", i);
}
```

## 5. 循环嵌套（Nested Loops）（以下是基础循环嵌套模板）

### 5.1 乘法表

```c
for (int i = 1; i <= 9; i++) {
    for (int j = 1; j <= 9; j++) {
        printf("%2d ", i * j);
    }
    printf("\n");
}
```

### 5.2 打印三角形

```c
int n = 5;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        printf("*");
    }
    printf("\n");
}
```

### 5.3 二维遍历与提前退出

```c
int a[3][3] = {
    {1,2,3},
    {4,5,6},
    {7,8,9}
};
int target = 5;
int ri = -1, rj = -1;
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (a[i][j] == target) {
            ri = i;
            rj = j;
            goto found2;
        }
    }
}
found2:
if (ri != -1) {
    printf("%d %d\n", ri, rj);
}
```

无需 `goto` 的等价写法：

```c
int done = 0;
for (int i = 0; i < 3 && !done; i++) {
    for (int j = 0; j < 3; j++) {
        if (a[i][j] == target) {
            ri = i;
            rj = j;
            done = 1;
            break;
        }
    }
}
if (done) {
    printf("%d %d\n", ri, rj);
}
```

要点：
- 嵌套循环的时间复杂度通常为平方或更高；谨慎评估规模。
- 从内层退出只影响内层；若需外层同时退出，使用标志变量或 `goto`。

----
# 第六部分：函数（Functions）
为了不重复写代码（**DRY原则** - Don't Repeat Yourself），我们将代码封装成函数。

## 1.函数的三要素
1. **声明/原型 (Prototype):** 放在文件顶部，告诉编译器“我有这个函数，请放心”。
    
2. **调用 (Call):** 在 `main` 中使用函数。
    
3. **定义 (Definition):** 函数具体的实现代码（通常放在文件底部）


### eg: 自定义一个meow函数


```c
#include <stdio.h>

// 1. Prototype: 告诉编译器有个函数叫 meow，接收一个 int，不返回任何值
void meow(int n);

int main(void)
{
    // 2. Call
    meow(3);
}

// 3. Definition: 具体实现
void meow(int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("meow\n");
    }
}
```


**下面内容为cs50，未提到的内容，可以考虑选看**

## 2. 参数与返回值（Parameters & Return Values）

### 2.1 值传递（Pass-by-Value）

```c
void set_to_42(int x) { x = 42; }

int a = 0;
set_to_42(a);
printf("%d\n", a); // 仍为 0
```

要点：
- C 的函数参数均按值传递；若要修改调用者的变量，传入其地址并解引用。

```c
void set_to_42p(int *px) { *px = 42; }
int a2 = 0;
set_to_42p(&a2);
printf("%d\n", a2); // 42
```

### 2.2 返回值与多返回

```c
int max(int a, int b) { return (a > b) ? a : b; }
```

多返回的常见做法：
- 结构体封装：

```c
typedef struct { int min; int max; } MinMax;
MinMax mm(int a, int b) { MinMax r = { a < b ? a : b, a > b ? a : b }; return r; }
```

- 输出参数：

```c
void minmax(int a, int b, int *out_min, int *out_max) {
    *out_min = (a < b) ? a : b;
    *out_max = (a > b) ? a : b;
}
```

### 2.3 返回指针的生命周期问题

```c
int *bad(void) {
    int x = 123;
    return &x; // 错误：返回了指向栈上局部变量的指针
}
```

要点：
- 不要返回指向局部变量的指针；可返回指向静态存储或堆分配的指针（堆需手动释放）。

## 3. 数组与指针作为参数

### 3.1 数组衰减与长度传递

```c
int sum(const int *arr, size_t n) {
    int s = 0;
    for (size_t i = 0; i < n; i++) s += arr[i];
    return s;
}

int a3[] = {1,2,3,4};
printf("%d\n", sum(a3, 4));
```

要点：
- 数组参数等价为指针；必须显式传递长度或使用终止标记。

### 3.2 修改与只读意图

```c
void fill(int *arr, size_t n, int v) {
    for (size_t i = 0; i < n; i++) arr[i] = v;
}
const char *msg = "hello"; // 只读字符串字面量
```

## 4. `const` 与指针修饰

```c
const int *p1;   // 指向常量的指针（不能改 *p1）
int *const p2;   // 常量指针（不能改 p2 指向）
const int *const p3; // 两者皆不可改
```

要点：
- 对只读数据使用 `const`，可提升安全性与优化机会。

## 5. 作用域与链接（Scope & Linkage）

### 5.1 文件作用域与内部链接

```c
static int counter = 0;     // 仅当前翻译单元可见
static void tick(void) { counter++; }
```

### 5.2 外部链接与跨文件

```c
// util.h
int add(int a, int b);

// util.c
int add(int a, int b) { return a + b; }

// main.c
#include <stdio.h>
#include "util.h"
int main(void) { printf("%d\n", add(2,3)); }
```

编译链接：

```sh
clang -c util.c -o util.o
clang -c main.c -o main.o
clang util.o main.o -o app
```

要点：
- 头文件放声明与原型，源文件放定义；避免在头文件中定义可产生重复符号。

## 6. 递归（Recursion）

```c
int fact(int n) { return (n <= 1) ? 1 : n * fact(n - 1); }
```

要点：
- 明确基例与收敛；避免过深递归导致栈溢出。

迭代等价：

```c
int fact_i(int n) { int r = 1; for (int i = 2; i <= n; i++) r *= i; return r; }
```

## 7. 函数指针与回调（Function Pointers & Callbacks）

```c
int cmp_int(const void *a, const void *b) {
    int ia = *(const int *)a;
    int ib = *(const int *)b;
    return (ia > ib) - (ia < ib);
}

int arr4[] = {5,2,9,1};
qsort(arr4, 4, sizeof(int), cmp_int);
```

声明与使用：

```c
int apply(int (*f)(int), int x) { return f(x); }
int square(int x) { return x * x; }
printf("%d\n", apply(square, 7));
```

## 8. 可变参数（Variadic Functions）

```c
#include <stdarg.h>
int sum_n(int count, ...) {
    va_list ap; va_start(ap, count);
    int s = 0;
    for (int i = 0; i < count; i++) s += va_arg(ap, int);
    va_end(ap);
    return s;
}
printf("%d\n", sum_n(4, 1, 2, 3, 4));
```

要点：
- 使用者与实现者需约定参数类型与数量；类型不匹配会产生未定义行为。

## 9. 内联与性能（`inline` & Performance）

```c
inline int addi(int a, int b) { return a + b; }
printf("%d\n", addi(1,2));
```

要点：
- `inline` 是编译器建议，是否内联由编译器决定；优化应以可读性与正确性优先。

## 10. 错误处理（Error Handling）

返回约定：
- 成功返回非负或 0，失败返回负值或特定码。

`errno`：

```c
#include <errno.h>
#include <stdio.h>
FILE *fp = fopen("missing.txt", "r");
if (!fp) { printf("errno=%d\n", errno); }
```

## 11. 头文件实践建议（Headers）

- 使用 include guard：

```c
// util.h
#ifndef UTIL_H
#define UTIL_H
int add(int a, int b);
#endif
```

- 仅在 `.h` 中放声明与内联小函数；将可变的全局变量声明为 `extern` 并在单个 `.c` 中定义。

# 第七部分：其他重要概念
### 1. 作用域 (Scope)

变量只在它被创建的 `{}` 花括号内有效。

- 如果在 `if` 里面定义了 `int x = 5;`，出了这个 `if`，`x` 就不存在了。

### 2. 注释 (Comments)

- `//` 单行注释。

- `/* ... */` 多行注释。
    
- **好习惯:** 代码是写给人看的，顺便给机器运行。写清晰的注释来解释“为什么”这样做。

### 3. 辅助工具

CS50 提供了强力的命令行工具：

- `style50 file.c`: 检查代码格式是否美观（缩进、空格）。
    
- `help50 make file`: 当编译报错看不懂时，它会用人话解释错误原因。
    
- `check50 ...`: 自动测试代码是否正确（提交作业前使用）。


-----
# 第八部分：溢出 (Overflow)

计算机的内存是有限的。当我们试图用有限的**位 (bits)** 来存储一个超出了它能表示范围的数值时，就会发生**溢出 (Overflow)**。<font color="#ff0000">这种情况，我们也可以叫做和溢位</font>

这就像汽车的里程表（Odometer）：当它走到 `999999` 时，再跑 1 公里，它不会变成 1000000，而是会回滚到 `000000`。

## 1. 整数溢出 (Integer Overflow)

### 1.1 无符号整数 (Unsigned Integer) 的回绕

假设我们有一个 3-bit 的整数，它能表示的最大值是 `111` (即十进制的 7)。

如果我们给 `111` 加 `1`：

Plaintext

```
  1 1 1  (7)
+ 0 0 1  (1)
-------
1 0 0 0  (8) -> 但我们要存进 3-bit 的空间
  ^
  溢出的这一位被丢弃
-------
  0 0 0  (0)
```

结果变成了 0！这被称为**回绕 (Wraparound)**。

**代码示例：**


```c 
#include <stdio.h>

int main(void)
{
    // unsigned char 通常占 8 bits，范围 0 ~ 255
    unsigned char x = 255; 
    
    printf("Before: %d\n", x);
    
    x = x + 1; // 发生溢出
    
    printf("After:  %d\n", x); // 输出 0
}
```

### 1.2 有符号整数 (Signed Integer) 的翻转

对于有符号整数（如 `int`），最高位是**符号位 (Sign Bit)**（0代表正，1代表负）。 当正数大到一定程度，进位波及到了符号位，正数就会突然变成负数。

> **注意：** 在标准 C 语言中，有符号整数溢出属于**未定义行为 (Undefined Behavior)**，但在大多数现代计算机上，它的表现是数值从最大正数跳变为最小负数。

**代码示例：**


```c
#include <stdio.h>
#include <limits.h> // 包含 INT_MAX 等常量

int main(void)
{
    int n = 2147483647; // 32位 int 的最大值 (INT_MAX)
    
    printf("n     = %d\n", n);
    
    n = n + 1;
    
    // 结果通常变成了 -2147483648
    printf("n + 1 = %d\n", n); 
}
```

## 2. 现实世界中的溢出危机

CS50 经常引用现实世界的例子来说明溢出的后果：

### 2.1 2038 年问题 (Year 2038 Problem)

Unix/Linux 系统使用一个 32 位的有符号整数 (`time_t`) 来记录时间，起点是 **1970年1月1日**。

- 这个计数器每秒加 1。
    
- 到了 **2038年1月19日**，这个 32 位整数将达到最大值。
    
- 再过一秒，它会溢出变成负数，系统时间会瞬间跳回 **1901年**。
    
- **解决方法：** 现在的系统正在逐渐迁移到 64 位整数来存储时间（可以用几千亿年）。
    

### 2.2 游戏中的例子

- **文明 (Civilization):** 传说中的“核平甘地”Bug。原本甘地的“侵略指数”是 1（最低），当游戏尝试降低这个数值时 `1 - 2`，由于使用了无符号整数，结果溢出变成了 `255`（极度暴力），导致他疯狂投核弹。（注：这其实是个流行的都市传说，但很好地解释了下溢出 Underflow）。
    
- **吃豆人 (Pac-Man):** 第 256 关会出现乱码，就是因为关卡计数器只有 8 位 (0-255)，程序无法处理 256。
    

## 3. 浮点数精度限制 (Truncation & Imprecision)

虽然这不完全叫“溢出”，但它是相关的内存限制问题。计算机用有限的位来表示无限的小数，必然会有误差。

### 3.1 精度丢失



```c
#include <stdio.h>

int main(void)
{
    // 浮点数并不总是精确的
    float x = 1.0 / 10.0;
    
    // 你以为打印出来是 0.100000000...
    // 实际上可能是 0.100000001490116...
    printf("%.20f\n", x); 
}
```

### 3.2 整数截断 (Truncation)

当把一个浮点数赋值给整数时，小数部分会被直接丢弃（不是四舍五入），这可能导致数据丢失。



```c
float pi = 3.14159;
int x = pi; // x 变成了 3，小数部分丢失
```

## 4. 如何预防溢出？

1. **选择合适的数据类型：** 如果数值可能很大，使用 `long` (64-bit) 而不是 `int` (32-bit)。如果涉及金钱，不要用 `float`（精度问题），通常用整数存“分”或者使用专门的库。
    
2. **预判边界：** 在进行加法之前，检查是否会超过最大值。
    
```c
    // 安全的加法检查逻辑
    if (b > INT_MAX - a) {
        printf("Error: Overflow will occur!\n");
    } else {
        int result = a + b;
    }
```
3. **使用工具：** 编译器通常有选项可以检测溢出（如 CS50 的 `check50` 或 Clang 的 sanitizer）。



# 第九部分：作业——参考我的题目集1






# CS50 学习笔记 (C语言基础与内存管理)

## 1. 数据类型 (Data Types)

C 语言中的数据类型决定了变量在内存中占用的空间大小以及存储数据的格式。

### 基本数据类型
| 类型 | 说明 | 大小 (通常) | 范围 (有符号) | 格式化占位符 |
| :--- | :--- | :--- | :--- | :--- |
| `char` | 字符型，存储单个字符 (ASCII) | 1 字节 (8 bits) | -128 ~ 127 | `%c` |
| `int` | 整型 | 4 字节 (32 bits) | -2^31 ~ 2^31-1 | `%i` 或 `%d` |
| `float` | 单精度浮点型 | 4 字节 | 约 6-7 位有效数字 | `%f` |
| `double` | 双精度浮点型 | 8 字节 | 约 15-16 位有效数字 | `%lf` |
| `void` | 空类型，无返回值或无参数 | - | - | - |

### CS50 特有类型 (需要 `#include <cs50.h>`)
| 类型 | 说明 | 底层实现 | 格式化占位符 |
| :--- | :--- | :--- | :--- |
| `bool` | 布尔型 (真/假) | `_Bool` (C99) | - |
| `string` | 字符串 | `char *` (字符指针) | `%s` |

### 类型修饰符
*   `unsigned`: 无符号（只能存正数，范围翻倍）。例如 `unsigned int`。
*   `long`: 长整型。`long long` 通常为 8 字节 (`%lli`)。
*   `short`: 短整型。通常为 2 字节 (`%hi`)。

---

## 2. 内存分区 (Memory Layout)

当程序运行时，操作系统会为其分配内存空间，通常分为以下几个区域：

1.  **代码区 (Text Segment)**
    *   存放编译后的机器指令（二进制代码）。
    *   通常是只读的。

2.  **全局/静态区 (Data/BSS Segment)**
    *   **初始化数据区 (Data)**: 存放已初始化的全局变量和 `static` 变量。
    *   **未初始化数据区 (BSS)**: 存放未初始化的全局变量（默认初始化为 0）。

3.  **栈 (Stack)**
    *   **用途**: 存放函数的**局部变量**、函数参数、返回地址。
    *   **特点**: 
        *   由编译器自动分配和释放。
        *   **后进先出 (LIFO)** 结构。
        *   空间较小（通常几 MB），生长方向通常是**向下**（高地址 -> 低地址）。
    *   **生命周期**: 函数调用结束，栈帧销毁，变量失效。

4.  **堆 (Heap)**
    *   **用途**: **动态内存分配**。
    *   **特点**: 
        *   由程序员手动分配 (`malloc`) 和释放 (`free`)。
        *   空间很大，生长方向通常是**向上**（低地址 -> 高地址）。
    *   **生命周期**: 直到被 `free` 或程序结束。

---

## 3. 指针与地址 (Pointers & Addresses)

### 核心概念
*   **内存地址**: 内存中每个字节都有一个唯一的编号（地址），通常用十六进制表示（如 `0x7ff...`）。
*   **指针**: 一个变量，其**值**是另一个变量的**地址**。

### 关键操作符
*   `&` (取地址运算符): 获取变量的内存地址。
    ```c
    int n = 50;
    int *p = &n; // p 存储了 n 的地址
    ```
*   `*` (解引用运算符): 访问指针指向地址上的值。
    ```c
    printf("%i", *p); // 输出 50
    *p = 20;          // 修改 n 的值为 20
    ```

### 指针与数组
*   数组名本质上是指向数组第一个元素的指针。
*   `arr[i]` 等价于 `*(arr + i)`。
*   **指针算术**: 指针加 1，地址增加的大小取决于指针指向的数据类型（`int*` 加 1 会增加 4 字节）。

---

## 4. 动态内存管理 (Dynamic Memory Management)

需要包含头文件 `<stdlib.h>`。

### 常用函数
1.  **`malloc(size_t size)`**
    *   分配 `size` 字节的未初始化内存。
    *   返回指向该内存的指针 (`void*`)，失败返回 `NULL`。
    *   示例: `int *arr = malloc(10 * sizeof(int));`

2.  **`free(void *ptr)`**
    *   释放之前由 `malloc` 分配的内存。
    *   **必须成对出现**: 有多少次 `malloc` 就应该有多少次 `free`。
    *   示例: `free(arr);`

3.  **`calloc(size_t nmemb, size_t size)`**
    *   分配内存并**初始化为 0**。

4.  **`realloc(void *ptr, size_t size)`**
    *   调整已分配内存的大小。

### 常见内存错误
1.  **内存泄漏 (Memory Leak)**
    *   分配了堆内存但忘记 `free`。
    *   后果: 程序运行时间越长，占用内存越多，最终导致系统崩溃。

2.  **段错误 (Segmentation Fault)**
    *   访问了不属于程序的内存地址。
    *   常见原因: 
        *   解引用 `NULL` 指针。
        *   访问已释放的内存 (Use After Free)。
        *   数组越界访问。
        *   试图修改只读内存（如字符串常量）。

3.  **缓冲区溢出 (Buffer Overflow)**
    *   向数组写入的数据超过了其容量，覆盖了相邻内存的数据。
    *   这是严重的安全漏洞。

---

## 5. 总结图示

```
高地址 (High Address)
+------------------+
|   命令行参数/环境变量 |
+------------------+
|      栈 (Stack)   |  ↓ 向下生长
|   (局部变量)      |
+------------------+
|         ↓        |
|                  |
|         ↑        |
+------------------+
|      堆 (Heap)    |  ↑ 向上生长
|   (malloc分配)    |
+------------------+
|   全局/静态区     |
| (Global/Static)  |
+------------------+
|     代码区        |
| (Text Segment)   |
+------------------+
低地址 (Low Address)
```

---

## 6. 数组 (Arrays)

数组是存储在连续内存位置的相同类型数据的集合。

*   **声明**: `int scores[3];`
*   **初始化**: `int scores[] = {72, 73, 33};`
*   **访问**: 使用索引 `scores[0]`。
*   **内存**: 数组名 `scores` 在表达式中通常会被转换为指向第一个元素的指针 `&scores[0]`。

---

## 7. 字符串 (Strings)

在 C 语言中，字符串实际上是字符数组，但有一个特殊的结束标志。

*   **字符 (`char`)**: 使用单引号，如 `'a'`。
*   **字符串 (`string`)**: 使用双引号，如 `"Hello"`。
*   **结束符 (`\0`)**: 字符串在内存中以空字符 (Null Character, ASCII 0) 结尾。

### 字符串的本质
字符串是 `char` 类型的数组。
`string s = "Hi!";` 在内存中实际上是：
| 索引 | 0 | 1 | 2 | 3 |
| :--- | :--- | :--- | :--- | :--- |
| **字符** | 'H' | 'i' | '!' | `\0` |
| **ASCII** | 72 | 105 | 33 | 0 |

可以通过索引访问单个字符：
```c
string s = "Hi!";
printf("%c\n", s[0]); // 输出 'H'
printf("%i\n", s[3]); // 输出 0
```

---

## 8. 字符串长度 (String Length)

计算字符串长度的核心思想是遍历数组，直到遇到结束符 `\0`。

### 自定义实现
```c
int string_length(string s) {
    int n = 0;
    while (s[n] != '\0') {
        n++;
    }
    return n;
}
```

### 标准库函数
在 `<string.h>` 头文件中，提供了标准函数 `strlen`：
```c
#include <string.h>
int len = strlen(s);
```

---

## 9. 字符大小写转换 (Case Manipulation)

### ASCII 原理
ASCII 表中，大写字母 'A' (65) 和小写字母 'a' (97) 之间相差 32。
*   转小写: `+ 32`
*   转大写: `- 32`

### 使用 `ctype.h`
C 标准库 `<ctype.h>` 提供了方便的函数：
```c
#include <ctype.h>

char c = 'a';
char upper = toupper(c); // 变为 'A'
```

**示例：将字符串转换为大写**
```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main(void) {
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++) {
        printf("%c", toupper(s[i]));
    }
    printf("\n");
}
```

---

## 10. 命令行参数 (Command Line Arguments)

`main` 函数可以接收命令行输入的参数。

### 定义
```c
int main(int argc, string argv[])
```
*   **`argc` (Argument Count)**: 参数的个数（包括程序名本身）。
*   **`argv` (Argument Vector)**: 字符串数组，存储具体的参数。

### 示例
```c
// 运行: ./greet David
int main(int argc, string argv[]) {
    if (argc == 2) {
        printf("Hello, %s\n", argv[1]);
    } else {
        printf("Hello, world\n");
    }
}
```

### 有趣的工具: Cowsay
一个在终端中用 ASCII 字符画牛并说话的程序。
```bash
cowsay "Hello CS50"
```

---

## 11. 密码学入门 (Cryptography)

### 凯撒密码 (Caesar Cipher)
一种简单的替换加密技术。将明文中的每个字母在字母表中移动固定数目的位置。

*   **加密算法**: $c_i = (p_i + k) \% 26$
    *   $p_i$: 明文字符索引 (0-25)
    *   $k$: 密钥 (移动步数)
    *   $c_i$: 密文字符索引

**示例**:
如果密钥是 1:
*   `A` -> `B`
*   `B` -> `C`
*   ...
*   `Z` -> `A`

这展示了如何通过算法改变数据的表现形式，就像之前的乱码其实是某种编码后的 "This was cs50"。
